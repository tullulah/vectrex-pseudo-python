#!/usr/bin/env node
/**
 * jsvecx_comparison_improved.cjs
 * Script mejorado basado en jsvecx_fixed_test.cjs para generar archivos de comparaci√≥n
 */

const fs = require('fs');
const path = require('path');

// Crear entorno m√≠nimo de navegador
global.window = {
  AudioContext: null,
  webkitAudioContext: null
};

global.document = {
  getElementById: () => ({ 
    getContext: () => ({
      getImageData: () => ({ data: new Array(1000) }),
      putImageData: () => {}
    })
  }),
  documentElement: {
    addEventListener: () => {}
  }
};

global.console = console;

function setupJSVecx() {
  console.log('[JSVecX Comparison] Loading and fixing jsvecx bundle...');
  
  // Leer el bundle y aplicar correcciones
  const bundlePath = path.join(__dirname, 'ide', 'frontend', 'src', 'generated', 'jsvecx', 'vecx_full.js');
  let bundleCode = fs.readFileSync(bundlePath, 'utf8');
  
  // Corregir la l√≠nea problem√°tica con length undefined
  bundleCode = bundleCode.replace(
    'const STEP2        = length; // (igual que macro original)',
    'const STEP2        = 2; // Fixed: length was undefined, using default value'
  );
  
  // Reemplazar export con CommonJS
  bundleCode = bundleCode.replace(
    'export { VecX, Globals };',
    'if (typeof module !== "undefined" && module.exports) { module.exports = { VecX, Globals }; }'
  );
  
  console.log('[JSVecX Comparison] Bundle corrections applied');
  
  // Ejecutar el bundle corregido
  eval(bundleCode);
  
  console.log('[JSVecX Comparison] Bundle executed successfully');
  
  // Verificar disponibilidad
  if (typeof VecX === 'undefined' || typeof Globals === 'undefined') {
    throw new Error('VecX or Globals not available after bundle execution');
  }
  
  console.log('[JSVecX Comparison] ‚úì VecX and Globals available');
  return { VecX, Globals };
}

function initializeEmulator(VecX, Globals) {
  // Cargar BIOS
  console.log('[JSVecX Comparison] Loading BIOS...');
  const biosPath = path.join(__dirname, 'ide', 'frontend', 'dist', 'bios.bin');
  const biosData = fs.readFileSync(biosPath);
  
  console.log(`[JSVecX Comparison] BIOS loaded: ${biosData.length} bytes`);
  
  // Convertir BIOS a string
  let biosString = '';
  for (let i = 0; i < biosData.length; i++) {
    biosString += String.fromCharCode(biosData[i]);
  }
  
  // Configurar globals
  Globals.romdata = biosString;
  Globals.cartdata = null;
  console.log('[JSVecX Comparison] ‚úì BIOS configured in Globals');
  
  // Crear y configurar VecX
  const vecx = new VecX();
  console.log('[JSVecX Comparison] ‚úì VecX instance created');
  
  // Inicializar componentes manualmente
  vecx.e6809.init(vecx);
  vecx.osint.init(vecx);
  console.log('[JSVecX Comparison] ‚úì Components initialized');
  
  // Reset completo
  vecx.vecx_reset();
  console.log('[JSVecX Comparison] ‚úì VecX reset completed');
  
  return vecx;
}

function captureSteps(vecx, maxSteps) {
  const states = [];
  const pcCounts = new Map();
  
  for (let step = 0; step < maxSteps; step++) {
    const pc = vecx.e6809.reg_pc;
    
    // Verificar PC v√°lido
    if (pc < 0 || pc > 0xFFFF) {
      console.log(`[JSVecX Comparison] Invalid PC at step ${step}: 0x${pc.toString(16)}`);
      break;
    }
    
    const opcode = vecx.read8(pc);
    const regA = vecx.e6809.reg_a & 0xFF;
    const regB = vecx.e6809.reg_b & 0xFF;
    const regX = vecx.e6809.reg_x.value & 0xFFFF;
    const regY = vecx.e6809.reg_y.value & 0xFFFF;
    const regS = vecx.e6809.reg_s.value & 0xFFFF;
    const regU = vecx.e6809.reg_u.value & 0xFFFF;
    const regDP = vecx.e6809.reg_dp & 0xFF;
    const regCC = vecx.e6809.reg_cc & 0xFF;
    
    const state = {
      step,
      pc,
      opcode,
      a: regA,
      b: regB,
      x: regX,
      y: regY,
      s: regS,
      u: regU,
      dp: regDP,
      cc: regCC
    };
    
    states.push(state);
    
    // Contar frecuencia de PC
    const pcHex = pc.toString(16).toUpperCase().padStart(4, '0');
    const opcodeHex = opcode.toString(16).toUpperCase().padStart(2, '0');
    const key = `PC=${pcHex} Opcode=0x${opcodeHex}`;
    pcCounts.set(key, (pcCounts.get(key) || 0) + 1);
    
    // Ejecutar paso de CPU
    try {
      const cycles = vecx.e6809.e6809_sstep(0, 0);
      if (cycles <= 0) {
        console.log(`[JSVecX Comparison] CPU returned ${cycles} cycles at step ${step}, stopping`);
        break;
      }
    } catch (err) {
      console.log(`[JSVecX Comparison] Error at step ${step}: ${err.message}`);
      break;
    }
    
    // Detectar bucles infinitos simples
    if (step > 2 && vecx.e6809.reg_pc === pc) {
      console.log(`[JSVecX Comparison] PC unchanged at step ${step}, possible infinite loop`);
      break;
    }
  }
  
  return { states, pcCounts };
}

function generateComparisonFile(steps, states, pcCounts, filename) {
  const lines = [];
  
  lines.push(`=== COMPARACI√ìN JSVecx (${steps} pasos) ===`);
  lines.push('Generated by JSVecx emulator test');
  lines.push(`BIOS Path: ${path.join(__dirname, 'ide', 'frontend', 'dist', 'bios.bin')}`);
  lines.push('');
  
  // Tabla de estados
  lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
  lines.push('‚îÇ Step ‚îÇ  PC  ‚îÇ Opcode ‚îÇ A  ‚îÇ B  ‚îÇ  X   ‚îÇ  Y   ‚îÇ  S   ‚îÇ  U   ‚îÇ DP ‚îÇ CC ‚îÇ');
  lines.push('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
  
  for (const state of states) {
    const line = 
      `‚îÇ ${state.step.toString().padStart(4)} ‚îÇ ` +
      `${state.pc.toString(16).toUpperCase().padStart(4, '0')} ‚îÇ ` +
      `  0x${state.opcode.toString(16).toUpperCase().padStart(2, '0')}   ‚îÇ ` +
      `${state.a.toString(16).toUpperCase().padStart(2, '0')} ‚îÇ ` +
      `${state.b.toString(16).toUpperCase().padStart(2, '0')} ‚îÇ ` +
      `${state.x.toString(16).toUpperCase().padStart(4, '0')} ‚îÇ ` +
      `${state.y.toString(16).toUpperCase().padStart(4, '0')} ‚îÇ ` +
      `${state.s.toString(16).toUpperCase().padStart(4, '0')} ‚îÇ ` +
      `${state.u.toString(16).toUpperCase().padStart(4, '0')} ‚îÇ ` +
      `${state.dp.toString(16).toUpperCase().padStart(2, '0')} ‚îÇ ` +
      `${state.cc.toString(16).toUpperCase().padStart(2, '0')} ‚îÇ`;
    lines.push(line);
  }
  
  lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
  lines.push('');
  
  // An√°lisis
  lines.push('üìà AN√ÅLISIS DE EJECUCI√ìN:');
  
  // Frecuencias de PC/Opcode m√°s comunes
  const sortedFreqs = Array.from(pcCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);
  
  lines.push('üî• TOP 10 PC/Opcode m√°s frecuentes:');
  for (const [key, count] of sortedFreqs) {
    lines.push(`  ${key} ‚Üí ${count} veces`);
  }
  
  // Estad√≠sticas generales
  const uniquePCs = new Set(states.map(s => s.pc)).size;
  const biosInstructions = states.filter(s => s.pc >= 0xE000).length;
  
  lines.push(`Direcciones PC √∫nicas visitadas: ${uniquePCs}`);
  lines.push(`Instrucciones ejecutadas en BIOS (>= 0xE000): ${biosInstructions}`);
  lines.push('');
  
  // Escribir archivo
  fs.writeFileSync(filename, lines.join('\n'), 'utf8');
  console.log(`[JSVecX Comparison] üìÑ Resultados guardados en: ${filename}`);
}

function runComparison(steps) {
  console.log(`\n=== COMPARACI√ìN JSVecx (${steps} pasos) ===`);
  
  try {
    const { VecX, Globals } = setupJSVecx();
    const vecx = initializeEmulator(VecX, Globals);
    const { states, pcCounts } = captureSteps(vecx, steps);
    
    const filename = `jsvecx_comparison_${steps}_steps.txt`;
    generateComparisonFile(steps, states, pcCounts, filename);
    
    console.log(`[JSVecX Comparison] ‚úì Capturados ${states.length} pasos exitosamente`);
    
    return states.length;
  } catch (error) {
    console.error(`[JSVecX Comparison] ‚úó Error en test de ${steps} pasos: ${error.message}`);
    return 0;
  }
}

function main() {
  console.log('üîç GENERADOR DE COMPARACIONES JSVecx MEJORADO');
  console.log('=============================================');
  
  const testSizes = [100, 500, 1000, 2000, 5000];
  
  for (const size of testSizes) {
    runComparison(size);
  }
  
  console.log('\n‚úÖ Todas las comparaciones JSVecx completadas');
}

if (require.main === module) {
  main();
}