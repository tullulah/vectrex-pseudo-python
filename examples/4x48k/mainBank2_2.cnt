BANK 2
EQU $00 
EQU $02 CURRENT_BANK
LABEL $C800 Vec_Snd_Shadow
COMMENT_LABEL $C800 Shadow of sound chip registers (15 bytes)
LABEL $C80F Vec_Btn_State
COMMENT_LABEL $C80F Current state of all joystick buttons
LABEL $C810 Vec_Prev_Btns
COMMENT_LABEL $C810 Previous state of all joystick buttons
LABEL $C811 Vec_Buttons
COMMENT_LABEL $C811 Current toggle state of all buttons
LABEL $C812 Vec_Button_1_1
COMMENT_LABEL $C812 Current toggle state of stick 1 button 1
LABEL $C813 Vec_Button_1_2
COMMENT_LABEL $C813 Current toggle state of stick 1 button 2
LABEL $C814 Vec_Button_1_3
COMMENT_LABEL $C814 Current toggle state of stick 1 button 3
LABEL $C815 Vec_Button_1_4
COMMENT_LABEL $C815 Current toggle state of stick 1 button 4
LABEL $C816 Vec_Button_2_1
COMMENT_LABEL $C816 Current toggle state of stick 2 button 1
LABEL $C817 Vec_Button_2_2
COMMENT_LABEL $C817 Current toggle state of stick 2 button 2
LABEL $C818 Vec_Button_2_3
COMMENT_LABEL $C818 Current toggle state of stick 2 button 3
LABEL $C819 Vec_Button_2_4
COMMENT_LABEL $C819 Current toggle state of stick 2 button 4
LABEL $C81A Vec_Joy_Resltn
COMMENT_LABEL $C81A Joystick A/D resolution ($80=min $00=max)
LABEL $C81B Vec_Joy_1_X
COMMENT_LABEL $C81B Joystick 1 left/right
LABEL $C81C Vec_Joy_1_Y
COMMENT_LABEL $C81C Joystick 1 up/down
LABEL $C81D Vec_Joy_2_X
COMMENT_LABEL $C81D Joystick 2 left/right
LABEL $C81E Vec_Joy_2_Y
COMMENT_LABEL $C81E Joystick 2 up/down
LABEL $C81F Vec_Joy_Mux
COMMENT_LABEL $C81F Joystick enable/mux flags (4 bytes)
LABEL $C81F Vec_Joy_Mux_1_X
COMMENT_LABEL $C81F Joystick 1 X enable/mux flag (=1)
LABEL $C820 Vec_Joy_Mux_1_Y
COMMENT_LABEL $C820 Joystick 1 Y enable/mux flag (=3)
LABEL $C821 Vec_Joy_Mux_2_X
COMMENT_LABEL $C821 Joystick 2 X enable/mux flag (=5)
LABEL $C822 Vec_Joy_Mux_2_Y
COMMENT_LABEL $C822 Joystick 2 Y enable/mux flag (=7)
LABEL $C823 Vec_Misc_Count
COMMENT_LABEL $C823 Misc counter/flag byte, zero when not in use
LABEL $C824 Vec_0Ref_Enable
COMMENT_LABEL $C824 Check0Ref enable flag
LABEL $C825 Vec_Loop_Count
COMMENT_LABEL $C825 Loop counter word (incremented in Wait_Recal)
LABEL $C827 Vec_Brightness
COMMENT_LABEL $C827 Default brightness
LABEL $C828 Vec_Dot_Dwell
COMMENT_LABEL $C828 Dot dwell time?
LABEL $C829 Vec_Pattern
COMMENT_LABEL $C829 Dot pattern (bits)
LABEL $C82A Vec_Text_HW
COMMENT_LABEL $C82A Default text height and width
LABEL $C82A Vec_Text_Height
COMMENT_LABEL $C82A Default text height
LABEL $C82B Vec_Text_Width
COMMENT_LABEL $C82B Default text width
LABEL $C82C Vec_Str_Ptr
COMMENT_LABEL $C82C Temporary string pointer for Print_Str
LABEL $C82E Vec_Counters
COMMENT_LABEL $C82E Six bytes of counters
LABEL $C82E Vec_Counter_1
COMMENT_LABEL $C82E First counter byte
LABEL $C82F Vec_Counter_2
COMMENT_LABEL $C82F Second counter byte
LABEL $C830 Vec_Counter_3
COMMENT_LABEL $C830 Third counter byte
LABEL $C831 Vec_Counter_4
COMMENT_LABEL $C831 Fourth counter byte
LABEL $C832 Vec_Counter_5
COMMENT_LABEL $C832 Fifth counter byte
LABEL $C833 Vec_Counter_6
COMMENT_LABEL $C833 Sixth counter byte
LABEL $C834 Vec_RiseRun_Tmp
COMMENT_LABEL $C834 Temp storage word for rise/run
LABEL $C836 Vec_Angle
COMMENT_LABEL $C836 Angle for rise/run and rotation calculations
LABEL $C837 Vec_Run_Index
COMMENT_LABEL $C837 Index pair for run
LABEL $C839 Vec_Rise_Index
COMMENT_LABEL $C839 Index pair for rise
LABEL $C83B Vec_RiseRun_Len
COMMENT_LABEL $C83B length for rise/run
LABEL $C83D Vec_Rfrsh
COMMENT_LABEL $C83D Refresh time (divided by 1.5MHz)
LABEL $C83D Vec_Rfrsh_lo
COMMENT_LABEL $C83D Refresh time low byte
LABEL $C83E Vec_Rfrsh_hi
COMMENT_LABEL $C83E Refresh time high byte
LABEL $C83F Vec_Music_Work
COMMENT_LABEL $C83F Music work buffer (14 bytes, backwards?)
LABEL $C842 Vec_Music_Wk_A
COMMENT_LABEL $C842 register 10
LABEL $C845 Vec_Music_Wk_7
COMMENT_LABEL $C845 register 7
LABEL $C846 Vec_Music_Wk_6
COMMENT_LABEL $C846 register 6
LABEL $C847 Vec_Music_Wk_5
COMMENT_LABEL $C847 register 5
LABEL $C84B Vec_Music_Wk_1
COMMENT_LABEL $C84B register 1
LABEL $C84D Vec_Freq_Table
COMMENT_LABEL $C84D Pointer to note-to-frequency table (normally $FC8D)
LABEL $C84F Vec_Max_Players
COMMENT_LABEL $C84F Maximum number of players for Select_Game
LABEL $C850 Vec_Max_Games
COMMENT_LABEL $C850 Maximum number of games for Select_Game
LABEL $C84F Vec_ADSR_Table
COMMENT_LABEL $C84F Storage for first music header word (ADSR table)
LABEL $C851 Vec_Twang_Table
COMMENT_LABEL $C851 Storage for second music header word ('twang' table)
LABEL $C853 Vec_Music_Ptr
COMMENT_LABEL $C853 Music data pointer
LABEL $C853 Vec_Expl_ChanA
COMMENT_LABEL $C853 Used by Explosion_Snd - bit for first channel used?
LABEL $C854 Vec_Expl_Chans
COMMENT_LABEL $C854 Used by Explosion_Snd - bits for all channels used?
LABEL $C855 Vec_Music_Chan
COMMENT_LABEL $C855 Current sound channel number for Init_Music
LABEL $C856 Vec_Music_Flag
COMMENT_LABEL $C856 Music active flag ($00=off $01=start $80=on)
LABEL $C857 Vec_Duration
COMMENT_LABEL $C857 Duration counter for Init_Music
LABEL $C858 Vec_Music_Twang
COMMENT_LABEL $C858 3 word 'twang' table used by Init_Music
LABEL $C858 Vec_Expl_1
COMMENT_LABEL $C858 Four bytes copied from Explosion_Snd's U-reg parameters
LABEL $C859 Vec_Expl_2
LABEL $C85A Vec_Expl_3
LABEL $C85B Vec_Expl_4
LABEL $C85C Vec_Expl_Chan
COMMENT_LABEL $C85C Used by Explosion_Snd - channel number in use?
LABEL $C85D Vec_Expl_ChanB
COMMENT_LABEL $C85D Used by Explosion_Snd - bit for second channel used?
LABEL $C85E Vec_ADSR_Timers
COMMENT_LABEL $C85E ADSR timers for each sound channel (3 bytes)
LABEL $C861 Vec_Music_Freq
COMMENT_LABEL $C861 Storage for base frequency of each channel (3 words)
LABEL $C867 Vec_Expl_Flag
COMMENT_LABEL $C867 Explosion_Snd initialization flag?
LABEL $C877 Vec_Expl_Timer
COMMENT_LABEL $C877 Used by Explosion_Snd
LABEL $C879 Vec_Num_Players
COMMENT_LABEL $C879 Number of players selected in Select_Game
LABEL $C87A Vec_Num_Game
COMMENT_LABEL $C87A Game number selected in Select_Game
LABEL $C87B Vec_Seed_Ptr
COMMENT_LABEL $C87B Pointer to 3-byte random number seed (=$C87D)
LABEL $C87D Vec_Random_Seed
COMMENT_LABEL $C87D Default 3-byte random number seed
LABEL $CBEA Vec_Default_Stk
COMMENT_LABEL $CBEA Default top-of-stack
LABEL $CBEB Vec_High_Score
COMMENT_LABEL $CBEB High score storage (7 bytes)
LABEL $CBF2 Vec_SWI3_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF2 Vec_SWI2_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF5 Vec_FIRQ_Vector
COMMENT_LABEL $CBF5 FIRQ interrupt vector (3 bytes)
LABEL $CBF8 Vec_IRQ_Vector
COMMENT_LABEL $CBF8 IRQ interrupt vector (3 bytes)
LABEL $CBFB Vec_SWI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFB Vec_NMI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFE Vec_Cold_Flag
COMMENT_LABEL $CBFE Cold start flag (warm start if = $7321)
LABEL $D000 VIA_port_b
COMMENT_LABEL $D000 VIA port B data I/O register
LABEL $D001 VIA_port_a
COMMENT_LABEL $D001 VIA port A data I/O register (handshaking)
LABEL $D002 VIA_DDR_b
COMMENT_LABEL $D002 VIA port B data direction register (0=input 1=output)
LABEL $D003 VIA_DDR_a
COMMENT_LABEL $D003 VIA port A data direction register (0=input 1=output)
LABEL $D004 VIA_t1_cnt_lo
COMMENT_LABEL $D004 VIA timer 1 count register lo (scale factor)
LABEL $D005 VIA_t1_cnt_hi
COMMENT_LABEL $D005 VIA timer 1 count register hi
LABEL $D006 VIA_t1_lch_lo
COMMENT_LABEL $D006 VIA timer 1 latch register lo
LABEL $D007 VIA_t1_lch_hi
COMMENT_LABEL $D007 VIA timer 1 latch register hi
LABEL $D008 VIA_t2_lo
COMMENT_LABEL $D008 VIA timer 2 count/latch register lo (refresh)
LABEL $D009 VIA_t2_hi
COMMENT_LABEL $D009 VIA timer 2 count/latch register hi
LABEL $D00A VIA_shift_reg
COMMENT_LABEL $D00A VIA shift register
LABEL $D00B VIA_aux_cntl
COMMENT_LABEL $D00B VIA auxiliary control register
LABEL $D00C VIA_cntl
COMMENT_LABEL $D00C VIA control register
LABEL $D00D VIA_int_flags
COMMENT_LABEL $D00D VIA interrupt flags register
LABEL $D00E VIA_int_enable
COMMENT_LABEL $D00E VIA interrupt enable register
LABEL $D00F VIA_port_a_nohs
COMMENT_LABEL $D00F VIA port A data I/O register (no handshaking)
LABEL $F000 Cold_Start
LABEL $F06C Warm_Start
LABEL $F14C Init_VIA
LABEL $F164 Init_OS_RAM
LABEL $F18B Init_OS
LABEL $F192 Wait_Recal
LABEL $F1A2 Set_Refresh
LABEL $F1AA DP_to_D0
LABEL $F1AF DP_to_C8
LABEL $F1B4 Read_Btns_Mask
LABEL $F1BA Read_Btns
LABEL $F1F5 Joy_Analog
LABEL $F1F8 Joy_Digital
LABEL $F256 Sound_Byte
LABEL $F259 Sound_Byte_x
LABEL $F25B Sound_Byte_raw
LABEL $F272 Clear_Sound
LABEL $F27D Sound_Bytes
LABEL $F284 Sound_Bytes_x
LABEL $F289 Do_Sound
LABEL $F28C Do_Sound_x
LABEL $F29D Intensity_1F
LABEL $F2A1 Intensity_3F
LABEL $F2A5 Intensity_5F
LABEL $F2A9 Intensity_7F
LABEL $F2AB Intensity_a
LABEL $F2BE Dot_ix_b
LABEL $F2C1 Dot_ix
LABEL $F2C3 Dot_d
LABEL $F2C5 Dot_here
LABEL $F2D5 Dot_List
LABEL $F2DE Dot_List_Reset
LABEL $F2E6 Recalibrate
LABEL $F2F2 Moveto_x_7F
LABEL $F2FC Moveto_d_7F
LABEL $F308 Moveto_ix_FF
LABEL $F30C Moveto_ix_7F
LABEL $F30E Moveto_ix_b
LABEL $F310 Moveto_ix
LABEL $F312 Moveto_d
LABEL $F34A Reset0Ref_D0
LABEL $F34F Check0Ref
LABEL $F354 Reset0Ref
LABEL $F35B Reset_Pen
LABEL $F36B Reset0Int
LABEL $F373 Print_Str_hwyx
LABEL $F378 Print_Str_yx
LABEL $F37A Print_Str_d
LABEL $F385 Print_List_hw
LABEL $F38A Print_List
LABEL $F38C Print_List_chk
LABEL $F391 Print_Ships_x
LABEL $F393 Print_Ships
LABEL $F3AD Mov_Draw_VLc_a
COMMENT_LABEL $F3AD count y x y x ...
LABEL $F3B1 Mov_Draw_VL_b
COMMENT_LABEL $F3B1 y x y x ...
LABEL $F3B5 Mov_Draw_VLcs
COMMENT_LABEL $F3B5 count scale y x y x ...
LABEL $F3B7 Mov_Draw_VL_ab
COMMENT_LABEL $F3B7 y x y x ...
LABEL $F3B9 Mov_Draw_VL_a
COMMENT_LABEL $F3B9 y x y x ...
LABEL $F3BC Mov_Draw_VL
COMMENT_LABEL $F3BC y x y x ...
LABEL $F3BE Mov_Draw_VL_d
COMMENT_LABEL $F3BE y x y x ...
LABEL $F3CE Draw_VLc
COMMENT_LABEL $F3CE count y x y x ...
LABEL $F3D2 Draw_VL_b
COMMENT_LABEL $F3D2 y x y x ...
LABEL $F3D6 Draw_VLcs
COMMENT_LABEL $F3D6 count scale y x y x ...
LABEL $F3D8 Draw_VL_ab
COMMENT_LABEL $F3D8 y x y x ...
LABEL $F3DA Draw_VL_a
COMMENT_LABEL $F3DA y x y x ...
LABEL $F3DD Draw_VL
COMMENT_LABEL $F3DD y x y x ...
LABEL $F3DF Draw_Line_d
COMMENT_LABEL $F3DF y x y x ...
LABEL $F404 Draw_VLp_FF
COMMENT_LABEL $F404 pattern y x pattern y x ... $01
LABEL $F408 Draw_VLp_7F
COMMENT_LABEL $F408 pattern y x pattern y x ... $01
LABEL $F40C Draw_VLp_scale
COMMENT_LABEL $F40C scale pattern y x pattern y x ... $01
LABEL $F40E Draw_VLp_b
COMMENT_LABEL $F40E pattern y x pattern y x ... $01
LABEL $F410 Draw_VLp
COMMENT_LABEL $F410 pattern y x pattern y x ... $01
LABEL $F434 Draw_Pat_VL_a
COMMENT_LABEL $F434 y x y x ...
LABEL $F437 Draw_Pat_VL
COMMENT_LABEL $F437 y x y x ...
LABEL $F439 Draw_Pat_VL_d
COMMENT_LABEL $F439 y x y x ...
LABEL $F46E Draw_VL_mode
COMMENT_LABEL $F46E mode y x mode y x ... $01
LABEL $F495 Print_Str
LABEL $F511 Random_3
LABEL $F517 Random
LABEL $F533 Init_Music_Buf
LABEL $F53F Clear_x_b
LABEL $F542 Clear_C8_RAM
COMMENT_LABEL $F542 never used by GCE carts?
LABEL $F545 Clear_x_256
LABEL $F548 Clear_x_d
LABEL $F550 Clear_x_b_80
LABEL $F552 Clear_x_b_a
LABEL $F55A Dec_3_Counters
LABEL $F55E Dec_6_Counters
LABEL $F563 Dec_Counters
LABEL $F56D Delay_3
COMMENT_LABEL $F56D 30 cycles
LABEL $F571 Delay_2
COMMENT_LABEL $F571 25 cycles
LABEL $F575 Delay_1
COMMENT_LABEL $F575 20 cycles
LABEL $F579 Delay_0
COMMENT_LABEL $F579 12 cycles
LABEL $F57A Delay_b
COMMENT_LABEL $F57A 5*B + 10 cycles
LABEL $F57D Delay_RTS
COMMENT_LABEL $F57D 5 cycles
LABEL $F57E Bitmask_a
LABEL $F584 Abs_a_b
LABEL $F58B Abs_b
LABEL $F593 Rise_Run_Angle
LABEL $F5D9 Get_Rise_Idx
LABEL $F5DB Get_Run_Idx
LABEL $F5EF Get_Rise_Run
LABEL $F5FF Rise_Run_X
LABEL $F601 Rise_Run_Y
LABEL $F603 Rise_Run_Len
LABEL $F610 Rot_VL_ab
LABEL $F616 Rot_VL
LABEL $F61F Rot_VL_Mode
LABEL $F62B Rot_VL_M_dft
LABEL $F65B Xform_Run_a
LABEL $F65D Xform_Run
LABEL $F661 Xform_Rise_a
LABEL $F663 Xform_Rise
LABEL $F67F Move_Mem_a_1
LABEL $F683 Move_Mem_a
LABEL $F687 Init_Music_chk
LABEL $F68D Init_Music
LABEL $F692 Init_Music_x
LABEL $F7A9 Select_Game
LABEL $F84F Clear_Score
LABEL $F85E Add_Score_a
LABEL $F87C Add_Score_d
LABEL $F8B7 Strip_Zeros
LABEL $F8C7 Compare_Score
LABEL $F8D8 New_High_Score
LABEL $F8E5 Obj_Will_Hit_u
LABEL $F8F3 Obj_Will_Hit
LABEL $F8FF Obj_Hit
LABEL $F92E Explosion_Snd
LABEL $FF9F Draw_Grid_VL
LABEL $FD0D music1
LABEL $FD1D music2
LABEL $FD81 music3
LABEL $FDD3 music4
LABEL $FE38 music5
LABEL $FE76 music6
LABEL $FEC6 music7
LABEL $FEF8 music8
LABEL $FF26 music9
LABEL $FF44 musica
LABEL $FF62 musicb
LABEL $FF7A musicc
LABEL $FF8F musicd
LABEL $F9F4 Char_Table
LABEL $FBD4 Char_Table_End
EQU $03 maxVaultEnemy
EQU $55 instLettBrt
COMMENT_LABEL $55 brightness of the instruction text during attract mode
EQU $03 delayReset
COMMENT_LABEL $03 how long to delay between switching sprites in animating the running or climbing Tom
LABEL $0094 explScale1
EQU $1C explScale2
EQU $28 fuelFillUp
COMMENT_LABEL $28 when a player respawns or starts the game, this is how much fuel he gets
EQU $22 FuelDelay
COMMENT_LABEL $22 how long to wait before removing a unit from the Fuel bar
EQU $04 MaxBits
COMMENT_LABEL $04 maximum # of bits allowed on screen at a time
EQU $0A maxGunShots
COMMENT_LABEL $0A when Tom picks up Gun, this is how many shots he gets
EQU $02 MaxPBulls
COMMENT_LABEL $02 maximum # of player bullets allowed on Platform levels
LABEL $00FC MAX_TEXT_HEIGHT
COMMENT_LABEL $00FC used for Game Over screen
LABEL $0085 maxEnMissH
EQU $03 MaxMSExpl
COMMENT_LABEL $03 maximum # of minestorm explosions allowed on screen at once
EQU $02 RecogDelay
EQU -$64 tomYLoc
COMMENT_LABEL -$64 #-124                 ; y-coordinate location of Tom's space ship
LABEL $0096 showScDuration
COMMENT_LABEL $0096 how long to shw the score
LABEL $0094 spaceScale
COMMENT_LABEL $0094 the scale (for MY_MOVE_TO_D) for player ship and enemy bullets
EQU $06 speedUp1
COMMENT_LABEL $06 what WaveNum the game starts to go faster overall (play movments, enemy movements, shots, etc)
EQU $09 speedUp2
COMMENT_LABEL $09 what WaveNum the game starts to go faster overall (play movments, enemy movements, shots, etc)
EQU $7E inActive
COMMENT_LABEL $7E used in platform to designate in-active enemies and in-active bullets
EQU $32 msExplSizeLg
COMMENT_LABEL $32 the large size of the minestorm explosion
EQU $1E msExplSizeMed
COMMENT_LABEL $1E the medium size of the minestorm explosion
EQU $0A msExplSizeSm
COMMENT_LABEL $0A the small size of the minestorm explosion
LABEL $EEBA minestormExplosionPattern
LABEL $EA7F minestorm_move_y_draw_x
LABEL $C880 PlayerSc
LABEL $C887 sfx_pointer
LABEL $C889 sfx_pointer2
LABEL $C88B sfx_pointer3
LABEL $C88D sfx_status
LABEL $C88E sfx_status2
LABEL $C88F sfx_status3
LABEL $C890 BackGndCtr
LABEL $C891 BkGndCtEnd
LABEL $C892 TomVisible
LABEL $C893 tomY
LABEL $C894 tomX
LABEL $C895 TomLastDir
LABEL $C896 TomActionData
LABEL $C897 TomDirData
LABEL $C898 ThrustCtr
LABEL $C899 secondStars
LABEL $C89A starsNmi
LABEL $C89B StarCount
LABEL $C89C DropFExpY
LABEL $C89D DropFExpX
LABEL $C89E DropFuelY
LABEL $C89F DropFuelY2
LABEL $C8A0 DropFuelX
LABEL $C8A1 DropFuelX2
LABEL $C8A2 DropFExpCtr
LABEL $C8A3 scale1
LABEL $C8A4 scale1_2
LABEL $C8A5 IconYCoord
LABEL $C8A6 nmi2
LABEL $C8A7 BTN3Psd
LABEL $C8A8 PowerUpNmi
LABEL $C8A9 PUTextBrt
LABEL $C8AA PUTextY
LABEL $C8AB PUTextX
LABEL $C8AC PowerUpTXT
LABEL $C8AE PUBarXCtr
LABEL $C8AF PowerUp
LABEL $C8B0 PowerUp2
LABEL $C8B1 PowerUpType
LABEL $C8B2 PowerUpTypeSav
LABEL $C8B3 ShieldOn
LABEL $C8B4 ShieldCtr
LABEL $C8B5 SHbright
LABEL $C8B6 ShowScoreCtr
LABEL $C8B7 DropFOnScr
LABEL $C8B8 DropFCntDn
LABEL $C8B9 DropFNmi
LABEL $C8BA DropFFlipped
LABEL $C8BB DropFFlipped2
LABEL $C8BC DropFSpr
LABEL $C8BE DropFSpr2
LABEL $C8C0 LowFuelSndCtr
LABEL $C8C1 CurMissY_s
LABEL $C8C2 CurMissX_s
LABEL $C8C3 barrierBright
LABEL $C8C4 doorYPos
LABEL $C8C5 doorXPos
LABEL $C8C6 interSection
LABEL $C8C7 shipFlyPtr
LABEL $C8C8 shipFlyPauseCtr
LABEL $C8C9 shipFlyThrPtr
LABEL $C8CA shipFlyPattern
LABEL $C8CC shipFlyPatRpt
LABEL $C8CD shipDoorOpening
LABEL $C8CE tomMovePattern
LABEL $C8D0 tomMovePtr
LABEL $C8D1 tomMovePauseCtr
LABEL $C8D2 Height
LABEL $C8D3 HeightSC
LABEL $C8D4 Width
LABEL $C8D5 padY
LABEL $C8D6 padX
LABEL $C8D7 EnShColW_1
LABEL $C8D8 EnShColW_2
LABEL $C8D9 EnShColW_3
LABEL $C8DA EnShColPadY
LABEL $C8DB EnShColPadX
LABEL $C8DC EnShColMYC
LABEL $C8DD MissYPad
LABEL $C8DE MissXPad
LABEL $C8DF ReverseEW
LABEL $C8E0 footStepsCtr
LABEL $C8E1 FinalCountDn
LABEL $C8E2 FinalExitY
LABEL $C8E3 OnExitLad
LABEL $C8E4 FuelUpSound
LABEL $C8E5 FuelFY
LABEL $C8E6 FuelFX
LABEL $C8E7 FuelFY2
LABEL $C8E8 FuelFX2
LABEL $C8E9 FuelPods
LABEL $C8EA Fuel3
LABEL $C8EB FuelCtr
LABEL $C8EC FuelWarnCtr
LABEL $C8ED delayCounter
LABEL $C8EE BirdSnd
LABEL $C8EF Counter
LABEL $C8F0 Counter2
LABEL $C8F1 ExitLadScale
LABEL $C8F2 expl1Y
LABEL $C8F3 expl2Y
LABEL $C8F4 expl3Y
LABEL $C8F5 expl4Y
LABEL $C8F6 expl1X
LABEL $C8F7 expl2X
LABEL $C8F8 expl3X
LABEL $C8F9 expl4X
LABEL $C8FA explosionSize
LABEL $C8FB explodeNmi
LABEL $C8FC ExplosionDR
LABEL $C8FD ExplosionDC
LABEL $C8FE ExplosionAC
LABEL $C900 ExplosionAC1
LABEL $C901 ExplosionAC2
LABEL $C902 ExplosionAC3
LABEL $C903 ExplosionAC4
LABEL $C904 ExplosionDC1
LABEL $C905 ExplosionDC2
LABEL $C906 ExplosionDC3
LABEL $C907 ExplosionDC4
LABEL $C908 explosion1Y
LABEL $C909 explosion1X
LABEL $C90A explosion2Y
LABEL $C90B explosion2X
LABEL $C90C explosionFlags
LABEL $C90D explBrightP
LABEL $C90E explSound
LABEL $C90F explScale
LABEL $C910 nmiMove
LABEL $C911 nmiMoveRes
LABEL $C912 nmiNewCnt
LABEL $C913 MTCountDown
LABEL $C915 MTTotalFr
LABEL $C916 MTBright
LABEL $C917 MTScale
LABEL $C918 msExpl1
LABEL $C921 msExpl2
LABEL $C92A msExpl3
LABEL $C933 MSE2Ctr
LABEL $C934 DeSpawnCtr
LABEL $C935 DeathCountDown
LABEL $C936 debugFlag
LABEL $C937 debug_0
LABEL $C938 debug_1
LABEL $C939 debug_2
LABEL $C93A debug_3
LABEL $C93B debug_4
LABEL $C93C dotScale
LABEL $C93D decScale
LABEL $C93E decScale2
LABEL $C93F decScale3
LABEL $C940 bright
LABEL $C941 bright2
LABEL $C942 bright3
LABEL $C943 BitsOnScr
LABEL $C944 BitsDir
LABEL $C945 BitsDir2
LABEL $C946 BitsDir3
LABEL $C947 BitsDir4
LABEL $C948 scale
LABEL $C949 scale2
LABEL $C94A scale3
LABEL $C94B GameScreen
LABEL $C94C GameOverCtr
LABEL $C94D ButtonPressed
LABEL $C94E TitleScrnCtr
LABEL $C94F TitleSngCtr
LABEL $C951 Tmp
LABEL $C952 Tmp2
LABEL $C953 Tmp3
LABEL $C954 Tmp4
LABEL $C955 Tmp5
LABEL $C956 Tmp6
LABEL $C957 Tmp7
LABEL $C958 Tmp8
LABEL $C959 ThreeSprPause
LABEL $C95A DoSoundPtr
LABEL $C95C DoSoundCtr
LABEL $C95D GameSpeed
LABEL $C95E GunShots
LABEL $C95F GunBitBrt
LABEL $C960 JumpDir
LABEL $C961 JumpProg
LABEL $C962 WaveEnOnScr
LABEL $C963 InBTCounter
LABEL $C964 Inertia
LABEL $C965 InertiaCD
LABEL $C966 introWaveNum
LABEL $C967 initEnCall
LABEL $C968 EnRptTable
LABEL $C96B EnemyYHold
LABEL $C96C EnemyXHold
LABEL $C96D EnemyType
LABEL $C96E EnemyType2
LABEL $C96F EnemyType3
LABEL $C970 EnemyInfo1
LABEL $C971 EnemyInfo2
LABEL $C972 EnemyInfo3
LABEL $C973 EnemyInfo4
LABEL $C974 EnemyInfo5
LABEL $C975 EnemyHealth
LABEL $C976 EnemyHealth2
LABEL $C977 EnemySpeed
LABEL $C978 EnemySpeed2
LABEL $C979 EnemySpeed3
LABEL $C97A EnemySpeed4
LABEL $C97B EnemySpeed5
LABEL $C97C EnMoveTbl1
LABEL $C986 EnSprList1
LABEL $C990 EnDuplCtr
LABEL $C995 EnCollH
LABEL $C996 EnSpeedCtr
LABEL $C997 EnSpeedCtr2
LABEL $C998 EnSpeedCtr3
LABEL $C999 EnSpeedCtr4
LABEL $C99A EnSpeedCtr5
LABEL $C99B EnBirdOnScr
LABEL $C99C Enemy1Pos
LABEL $C9A1 Enemy1Y
LABEL $C9A2 Enemy2Y
LABEL $C9A3 Enemy3Y
LABEL $C9A4 Enemy4Y
LABEL $C9A5 Enemy5Y
LABEL $C9A6 Enemy6Y
LABEL $C9A7 Enemy7Y
LABEL $C9A8 Enemy8Y
LABEL $C9A9 Enemy9Y
LABEL $C9AA Enemy10Y
LABEL $C9AB Enemy11Y
LABEL $C9AC Enemy12Y
LABEL $C9AD Enemy13Y
LABEL $C9AE Enemy14Y
LABEL $C9AF Enemy15Y
LABEL $C9B0 Enemy1X
LABEL $C9B1 Enemy2X
LABEL $C9B2 Enemy3X
LABEL $C9B3 Enemy4X
LABEL $C9B4 Enemy5X
LABEL $C9B5 Enemy6X
LABEL $C9B6 Enemy7X
LABEL $C9B7 Enemy8X
LABEL $C9B8 Enemy9X
LABEL $C9B9 Enemy10X
LABEL $C9BA Enemy11X
LABEL $C9BB Enemy12X
LABEL $C9BC Enemy13X
LABEL $C9BD Enemy14X
LABEL $C9BE Enemy15X
LABEL $C9BF EnemyM1Ctr
LABEL $C9C4 EnemyMiss1Y
LABEL $C9C5 EnemyMiss2Y
LABEL $C9C6 EnemyMiss3Y
LABEL $C9C7 EnemyMiss4Y
LABEL $C9C8 EnemyMiss5Y
LABEL $C9C9 EnemyMiss1X
LABEL $C9CA EnemyMiss2X
LABEL $C9CB EnemyMiss3X
LABEL $C9CC EnemyMiss4X
LABEL $C9CD EnemyMiss5X
LABEL $C9CE EnemyReplen
LABEL $C9CF EnemyM1Info
LABEL $C9D4 Phase2Ctr
LABEL $C9D5 PlBullCount
LABEL $C9D6 plBullSpeed
LABEL $C9D7 PlatEnOS
LABEL $C9D8 PlatLocY
LABEL $C9D9 PlatLocX
LABEL $C9DA PlatLocY2
LABEL $C9DB PlatLocX2
LABEL $C9DC PlatScale
LABEL $C9DD PlatExitLad
LABEL $C9DF PlatCompCtr
LABEL $C9E0 PlatData
LABEL $C9E2 PlatLads
LABEL $C9E4 Plat_R1
LABEL $C9E6 Plat_R2
LABEL $C9E8 Plat_R3
LABEL $C9EA PlatFlags
LABEL $C9EB PlatPreInit
LABEL $C9EC PlatMinX
LABEL $C9ED PlatMaxX
LABEL $C9EE PlatGuns
LABEL $C9F0 PlatGunX1
LABEL $C9F1 PlatGunX2
LABEL $C9F2 PlatGunY1
LABEL $C9F3 PlatGunY2
LABEL $C9F4 PlatLevel
LABEL $C9F5 PlatNmMvTbl
LABEL $C9F8 PlatMvSpNum
LABEL $C9FB PlatMvNum
LABEL $C9FE PlatMvNumH
LABEL $C9FF PlatNmMvTblH
LABEL $CA00 PlatMvSpNumH
LABEL $CA01 CurrEnSCtrH
LABEL $CA02 PlatMovTblH
LABEL $CA04 PlatMovTbl
LABEL $CA0E ShrStarted
LABEL $CA0F ShrDelay
LABEL $CA10 SubWaveNum
LABEL $CA11 WaveChaseSp
LABEL $CA12 WaveChaseSr
LABEL $CA13 WaveMaxBull
LABEL $CA14 WaveMaxEn
LABEL $CA15 WaveNumKill
LABEL $CA16 WavSkipStrs
LABEL $CA17 WaveNumStr
LABEL $CA1E IncMY
LABEL $CA1F IncMX
LABEL $CA20 incTX
LABEL $CA21 incTY
LABEL $CA22 CurrBckGndSnd
LABEL $CA24 CurrPlatPF
LABEL $CA26 CurrPlatPF2
LABEL $CA28 CurrPlatRules
LABEL $CA2A RulesInAction
LABEL $CA2B RulesInAction2
LABEL $CA2C RulesInAction3
LABEL $CA2D LstRIAIndex
LABEL $CA2E LstEnemyType
LABEL $CA2F CurrMissInf
LABEL $CA30 CurrLevel
LABEL $CA31 CurMissY
LABEL $CA32 CurMissX
LABEL $CA33 CurMissSpr
LABEL $CA34 CurMissSCr
LABEL $CA35 CurrEnShoot
LABEL $CA36 CurrIncY
LABEL $CA37 CurrIncX
LABEL $CA38 CurrEnPos
LABEL $CA39 CurrEnSCtr
LABEL $CA3A CurrDupCtr
LABEL $CA3B CurrMSprite
LABEL $CA3C runNmiP
LABEL $CA3D runNmi
LABEL $CA3E Recog1Info
LABEL $CA3F Recog2Info
LABEL $CA40 Recog3Info
LABEL $CA41 RecogPause
LABEL $CA42 RecogPCtr
LABEL $CA43 RecogSpeed
LABEL $CA44 RecogSpdCtr
LABEL $CA45 RecogOnScr
LABEL $CA46 RecogAnimCtr
LABEL $CA47 RecogCounter
LABEL $CA48 RecogX1
LABEL $CA49 RecogX2
LABEL $CA4A RecogX3
LABEL $CA4B RecogY1
LABEL $CA4C RecogY2
LABEL $CA4D RecogY3
LABEL $CA4E RecogNmFlag
LABEL $CA4F LadYStart
LABEL $CA50 LadYEnd
LABEL $CA51 LastSubWave
LABEL $CA52 isTinySquad
LABEL $CA53 SquadMoveTbl
LABEL $CA55 SquadSprite
LABEL $CA57 SquadCollDet
LABEL $CA58 SquadShSpeed
LABEL $CA67 WarpTxtCtr
LABEL $CA68 WarpTxtY
LABEL $CA69 WarpTxtX
LABEL $CA6A WarpTxtBrt
LABEL $CA6B WarpSpeed
LABEL $CA6C WarpSecCtr
LABEL $CA6D WavePutOnScr
LABEL $CA6E WaveNum
LABEL $CA6F WaveNxtEnNm
LABEL $CA70 WaveNumEn
LABEL $CA71 WaveLstEnK
LABEL $CA72 WaveType
LABEL $CA73 WaveEnWait
LABEL $CA74 WaveEnWait2
LABEL $CA75 WaveEnWait3
LABEL $CA76 WaveEnWait4
LABEL $CA77 WaveEnWait5
LABEL $CA78 WaveEnWait6
LABEL $CA79 WaveEnWait7
LABEL $CA7A WaveEnWait8
LABEL $CA7B WaveEnWait9
LABEL $CA7C WaveEnWait10
LABEL $CA7D WaveEnWait11
LABEL $CA7E WaveEnWait12
LABEL $CA7F WaveEnWait13
LABEL $CA80 WaveEnWait14
LABEL $CA81 WaveMultiSptr
LABEL $CA9D WaveSubDraw
LABEL $CA9E WaveSqAnims
LABEL $CA9F WaveSqFrames
LABEL $CAA0 WaveSqFraCtr
LABEL $CAA1 WaveSqSprites
LABEL $CAA3 WaveAnimSpr
LABEL $CAA5 WaveSqCurPtr
LABEL $CAA6 WaveSqAcSpr
LABEL $CAA8 CurrEnY
LABEL $CAA9 CurrEnX
LABEL $CAAA CurrEnInfo
LABEL $CAAB CurrMovTbl
LABEL $CAAD CurrSprList
LABEL $CAAF CurrShSpeed
LABEL $CAB0 CurrVol
LABEL $CAB1 CurrTone
LABEL $CAB2 BulletPlDir
LABEL $CAB3 BulletC1Y
LABEL $CAB4 BulletC1X
LABEL $CAB5 Bullet1YPos
LABEL $CAB6 Bullet2YPos
LABEL $CAB7 Bullet3YPos
LABEL $CAB8 Bullet1XPos
LABEL $CAB9 Bullet2XPos
LABEL $CABA Bullet3XPos
LABEL $CABB BitPickedUp
LABEL $CABC BitsAllPicked
LABEL $CABD BitY1
LABEL $CABE BitY2
LABEL $CABF BitY3
LABEL $CAC0 BitY4
LABEL $CAC1 BitX1
LABEL $CAC2 BitX2
LABEL $CAC3 BitX3
LABEL $CAC4 BitX4
LABEL $CAC5 BitSprite
LABEL $CAC9 ShotCtr
LABEL $CACA SpawnDec
LABEL $CACB SpawnEnd
LABEL $CACC SpawnType
LABEL $CACD SpawnHeight
LABEL $CACE DespawnEnemy
LABEL $CACF SpawnDelay
LABEL $CAD0 SpawnCounter
LABEL $CAD1 SpawnLoopCtr
LABEL $CAD2 SpawnY
LABEL $CAD3 SpawnX
LABEL $CAD4 AttrCtr
LABEL $CAD5 AttrCtr2
LABEL $CAD6 AttrMode
LABEL $CAD7 animationCounter
LABEL $CAD9 TitleSong
LABEL $CADA TitleSongPtr
LABEL $CADC VolPos
LABEL $CADD LoopCtr
LABEL $CADE nmi
LABEL $CADF nmiR
LABEL $CAE0 MaxRecNum
LABEL $CAE1 maxBullH
LABEL $CAE2 MusicState
LABEL $CAE3 SpacePlatLvl
LABEL $CAE4 ShipPos
LABEL $CAE5 GSRScale
LABEL $CAE6 GSRScaleSav
LABEL $CAE7 GSRemaining1
LABEL $CAE8 GSRemaining2
LABEL $CAE9 GSRemaining3
LABEL $CAEA GSRemaining4
LABEL $CAEB GenericFlag
LABEL $CAEC enemyDrwNmi
LABEL $CAED Lives
LABEL $CAEE DisplayLives
LABEL $CAEF Cv1Ctr
LABEL $CAF0 FrameCtrEI
LABEL $CAF1 ExtraMan
LABEL $CAF8 ExtraManSnd
LABEL $CAF9 BonusPts
LABEL $CB00 buffer
LABEL $CB00 Vec_Text_Width_neg
COMMENT_LABEL $CB00 variable used in own printing routines
LABEL $CB02 print_space
COMMENT_LABEL $CB02 buffer for draw numbers
LABEL $CB01 ym_ram
LABEL $0242 main
EQU $29 jmpBank0_T1
EQU $40 jmpBank1_T1
EQU $57 jmpBank0_Shift
EQU $71 jmpBank1_Shift
LABEL $008B jmpBank2_Shift
LABEL $00A5 jmpBank3_Shift
LABEL $00BF jmpBank2
LABEL $00D1 jmpBank3
LABEL $00E3 jsrBank3to0T1
LABEL $010B jsrBank3to0_Shift
LABEL $0136 jsrBank2to0_T1
LABEL $014E jsrBank2to0_Shift
LABEL $0169 jsrBank1to0
LABEL $0169 jsrBank3to2
LABEL $017C jsrBank0to1
LABEL $017C jsrBank2to3
LABEL $018F jsrBank3to1T1
LABEL $01A7 jsrBank3to1_Shift
LABEL $01C2 jsrBank2to1T1
LABEL $01EA jsrBank2to1_Shift
LABEL $0215 jsrBank1to2_Shift
LABEL $0720 playSound
LABEL $02A8 EnemyTwo
LABEL $0273 printBankString
LABEL $0271 outMain
LABEL $026B REPLACE_1_2_main_varFromBank3_0
LABEL $028E bank_string1
LABEL $0296 bank_string2
EQU $00 INFO_START
EQU $00 BYTE_POS
EQU $02 BIT_POS
EQU $03 CBYTE
EQU $04 CU_BYTE
EQU $05 CRLE_COUNTER
EQU $07 CRLE_MAPPER
EQU $09 CIS_PHRASE
EQU $0B CP_BYTE
EQU $0C CP_START
EQU $0E REG_USED
EQU $0F INFO_END
EQU $0F STRUCT_LEN
LABEL $CB01 cregister
LABEL $CB02 temp
LABEL $CB03 temp2
LABEL $CB04 temp3
LABEL $CB05 calc_coder
LABEL $CB06 calc_bits
LABEL $CB07 ym_len
LABEL $CB09 ym_data_current
LABEL $CB0B ym_name
LABEL $CB0D ym_regs_used
LABEL $CB0E ym_regs_count
LABEL $CB0F ym_data_start
LABEL $02B9 do_ym_sound
LABEL $02DC ymsodone
LABEL $02CD next_reg
LABEL $0352 get_cbyte
LABEL $02DD nv_byte
LABEL $02ED bready_1
LABEL $0374 ns_byte
LABEL $02F5 si_byte
LABEL $02F7 dechifer
LABEL $02FD tn_bit
LABEL $0313 bready
LABEL $031C no_add
LABEL $031E sagain
LABEL $034C no_p_d
LABEL $0346 pfound
LABEL $033F nphrase
LABEL $0352 out
LABEL $036C no_p
LABEL $0371 cnotmone
LABEL $0379 mbits
LABEL $038C bready_2
LABEL $0399 go_on
LABEL $03A9 bready_3
LABEL $03B1 ehere_3
LABEL $03B3 go_on_2
LABEL $03C3 bready_4
LABEL $03CB ehere_4
LABEL $03CC snotydone
LABEL $03D2 no_carry
LABEL $03D7 sdone
LABEL $03EC init_ym_sound
LABEL $0405 nreg_init
LABEL $0422 regInitDone
LABEL $0426 warp_start_2_start
LABEL $0428 warp_start_2_reg_0
LABEL $0467 warp_start_2_pd_0
LABEL $0467 warp_start_2_reg_0_data
LABEL $0484 warp_start_2_reg_1
LABEL $0487 warp_start_2_pd_1
LABEL $0487 warp_start_2_reg_1_data
LABEL $048A warp_start_2_reg_2
LABEL $04EA warp_start_2_pd_2
LABEL $04F9 warp_start_2_reg_2_data
LABEL $0541 warp_start_2_reg_3
LABEL $055C warp_start_2_pd_3
LABEL $056B warp_start_2_reg_3_data
LABEL $0598 warp_start_2_reg_4
LABEL $05D7 warp_start_2_pd_4
LABEL $05D7 warp_start_2_reg_4_data
LABEL $05F4 warp_start_2_reg_5
LABEL $05F7 warp_start_2_pd_5
LABEL $05F7 warp_start_2_reg_5_data
LABEL $05FA warp_start_2_reg_6
LABEL $05FD warp_start_2_pd_6
LABEL $05FD warp_start_2_reg_6_data
LABEL $0600 warp_start_2_reg_7
LABEL $0606 warp_start_2_pd_7
LABEL $0606 warp_start_2_reg_7_data
LABEL $060A warp_start_2_reg_8
LABEL $0628 warp_start_2_pd_8
LABEL $0628 warp_start_2_reg_8_data
LABEL $0636 warp_start_2_reg_9
LABEL $0654 warp_start_2_pd_9
LABEL $0654 warp_start_2_reg_9_data
LABEL $0694 warp_start_2_reg_10
LABEL $06B2 warp_start_2_pd_10
LABEL $06B2 warp_start_2_reg_10_data
LABEL $06C0 warp_start_2_data
LABEL $06C0 warp_start_2
LABEL $0710 warp_start_2_name
LABEL $072C checkRestart
LABEL $0743 aftSound
LABEL $0738 restartBck
LABEL $0744 *
COMMENT_LINE $0000 ; hey dissi "watch $WaveNum 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $Tmp 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $Tmp6 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $Tmp5 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $Tmp3 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $RulesInAction 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $enemyDrwNmi 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $tomY 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $tomX 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $CurMissY 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $CurMissX 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $ReverseEW 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $DropFNmi 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $secondStars 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $LoopCtr 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $enemyDrwNmi 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $EnMissCutOff 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $Lives 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $EnemyHealth 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $GameScreen 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $BkGndCtEnd 1 0"
COMMENT_LINE $0000 ; hey dissi "watch $WaveMaxBull 1 0"
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 all banks start with this!
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 DEFINE SECTION
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 load vectrex bios routine definitions
COMMENT $C800 RAM and defines
COMMENT_LINE $C800 load vectrex bios routine definitions
COMMENT $C800 vectrex function includes
COMMENT_LINE $C800 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C800 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $C800 it was written by Bruce Tomlin, slighte changed by Malban                 ;
COMMENT_LINE $C800 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C800 $C839                             ;Pointer to copyright string during startup
COMMENT_LINE $C800 $C83B                             ;High score cold-start flag (=0 if valid)
COMMENT_LINE $C800 $C83C                             ;temp byte
COMMENT_LINE $C800 $C843                             ;        register 9
COMMENT_LINE $C800 $C844                             ;        register 8
COMMENT_LINE $C800 $C848                             ;        register 4
COMMENT_LINE $C800 $C849                             ;        register 3
COMMENT_LINE $C800 $C84A                             ;        register 2
COMMENT_LINE $C800 $C84C                             ;        register 0
COMMENT_LINE $C800 $C85E                             ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT_LINE $C800 $C868...$C876                             ;Unused?
COMMENT_LINE $C800 $C878                             ;Unused?
COMMENT_LINE $C800 $C880 - $CBEA is user RAM                            ;
COMMENT_LINE $C800 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $C800 1 mux sel 0
COMMENT_LINE $C800 2 mux sel 1
COMMENT_LINE $C800 3 sound BC1
COMMENT_LINE $C800 4 sound BDIR
COMMENT_LINE $C800 5 comparator input
COMMENT_LINE $C800 6 external device (slot pin 35) initialized to input
COMMENT_LINE $C800 7 /RAMP
COMMENT_LINE $C800 0 PA latch enable
COMMENT_LINE $C800 1 PB latch enable
COMMENT_LINE $C800 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $C800 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $C800 4 /
COMMENT_LINE $C800 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $C800 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $C800 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT_LINE $C800 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $C800 1 \
COMMENT_LINE $C800 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $C800 3 /
COMMENT_LINE $C800 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $C800 5 \
COMMENT_LINE $C800 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $C800 7 /
COMMENT_LINE $C800 bit                             cleared by
COMMENT_LINE $C800 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C800 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C800 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $C800 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $C800 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C800 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $C800 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $C800 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT_LINE $C800 0 CA2 interrupt enable
COMMENT_LINE $C800 1 CA1 interrupt enable
COMMENT_LINE $C800 2 shift register interrupt enable
COMMENT_LINE $C800 3 CB2 interrupt enable
COMMENT_LINE $C800 4 CB1 interrupt enable
COMMENT_LINE $C800 5 timer 2 interrupt enable
COMMENT_LINE $C800 6 timer 1 interrupt enable
COMMENT_LINE $C800 7 IER set/clear control
COMMENT_LINE $C800 Rot_VL_dft      EQU     $F637   ;
COMMENT_LINE $C800 Rot_VL_ab       EQU     $F610   ;
COMMENT_LINE $C800 Rot_VL          EQU     $F616   ;
COMMENT_LINE $C800 Rot_VL_Mode_a   EQU     $F61F   ;
COMMENT_LINE $C800 Rot_VL_Mode     EQU     $F62B   ;
COMMENT_LINE $C800 Rot_VL_dft      EQU     $F637   ;
COMMENT $C800 vectrex macro includes
COMMENT_LINE $C800 PC not usable :-)
COMMENT_LINE $C800 cmpx #4
COMMENT_LINE $C800 pshs d,y,x,pc,u,cc;16
COMMENT_LINE $C800 puls d,y,x,pc,u,cc; 16
COMMENT_LINE $C800 pshs y,x,pc,u,d;15
COMMENT_LINE $C800 puls y,x,pc,u,d; 15
COMMENT_LINE $C800 pshs y,x,pc,u,cc;14
COMMENT_LINE $C800 puls y,x,pc,u,cc; 14
COMMENT_LINE $C800 pshs a,x,pc,u,cc;13
COMMENT_LINE $C800 puls a,x,pc,u,cc;13
COMMENT_LINE $C800 pshs x,pc,u,cc;12
COMMENT_LINE $C800 puls x,pc,u,cc;12
COMMENT_LINE $C800 pshs pc,u,d;11
COMMENT_LINE $C800 puls pc,u,d;11
COMMENT_LINE $C800 pshs pc,u,cc;10
COMMENT_LINE $C800 puls pc,u,cc;10
COMMENT_LINE $C800 pshs u,d;9
COMMENT_LINE $C800 puls u,d;9
COMMENT_LINE $C800 pshs u,cc;8
COMMENT_LINE $C800 puls u,cc;8
COMMENT_LINE $C800 pshs u;7
COMMENT_LINE $C800 puls u;7
COMMENT_LINE $C800 pshs cc;6
COMMENT_LINE $C800 puls cc;6
COMMENT_LINE $C800 tfr a,a; 6
COMMENT_LINE $C800 brn 0; 3
COMMENT_LINE $C800 NOP ; 2
COMMENT_LINE $C800 the "massive" stack usage is forbidden -> since stack is rare and
COMMENT_LINE $C800 can overwrite data
COMMENT $0000 wait 2 cycles
COMMENT $0000 wait 3 cycles
COMMENT $0000 wait 6 cycles
COMMENT $0000 wait 12 cycles
COMMENT $0000 wait 14 cycles
COMMENT $0000 wait 16 cycles
COMMENT $0000 wait 18 cycles
COMMENT $0000 wait 20 cycles
COMMENT $0000 wait 22 cycles
COMMENT $0000 wait 24 cycles
COMMENT $0000 wait 26 cycles
COMMENT $0000 wait 28 cycles
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 macro D = D *2
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 macro D = D /2
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 definition of bank switch macros
COMMENT $0000 Prepare DDR Registers % 1101 1111 1111 1111
COMMENT $0000 all ORB/ORA to output except ORB 5, PB6 goes LOW
COMMENT $0000 A = $01, B = 0
COMMENT $0000 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
COMMENT_LINE $0000 .....
COMMENT $0000 Prepare DDR Registers % 1001 1111 1111 1111
COMMENT $0000 all ORB/ORA to output except ORB 5, PB6 goes LOW
COMMENT $0000 A = $01, B = 0
COMMENT $0000 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
COMMENT_LINE $0000 .....
COMMENT $0000 interrupt DISABLED - clear ALL interrupts to ensure other bank
COMMENT $0000 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
COMMENT_LINE $0000 ensure shift is "normal"
COMMENT $0000 0 = shift,
COMMENT_LINE $0000 .....
COMMENT $0000 interrupt ENABLED
COMMENT $0000 bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
COMMENT_LINE $0000 and now "trigger a interrupt"
COMMENT $0000 a VERY short T1 timer
COMMENT $0000 start timer
COMMENT $0000 by the time, the macros "leaves" the interrupt is set!
COMMENT_LINE $0000 .....
COMMENT $0000 interrupt ENABLED
COMMENT $0000 ensure that shift can generate interrupt
COMMENT_LINE $0000 for some reason or another, VIA doesn't like a
COMMENT_LINE $0000 std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $0000 (only on a real vectrex, not Vide)
COMMENT $0000 and write 0 to shift (a) and $98 to aux (shift out enable)
COMMENT $0000 bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
COMMENT_LINE $0000 wait 20 cycles till store of aux (these are 23)
COMMENT $0000 12
COMMENT $0000 3
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 *******************************************************************
COMMENT_LINE $0000 ********************** STRUCTRUES *********************************
COMMENT_LINE $0000 *******************************************************************
COMMENT_LINE $0000 ...
COMMENT_LINE $0000 *******************************************************************
COMMENT_LINE $0000 ********************** CONSTANTS **********************************
COMMENT_LINE $0000 *******************************************************************
COMMENT_LINE $0000 ...
COMMENT_LINE $0000 *******************************************************************
COMMENT_LINE $0000 ********************** RAM ****************************************
COMMENT_LINE $0000 *******************************************************************
COMMENT_LINE $0000 RAM that is "always" the same
COMMENT_LINE $C800 constants
COMMENT_LINE $C800 delayResetSp        EQU      1                            ; how long to delay between the animations of the spawn
COMMENT_LINE $C800 !!!!!!!! PUT ABOVE IN ALPHABETICAL ORDER!!!!!!
COMMENT_LINE $C800 C880-CBEA is available ram on the VECTREX
COMMENT_LINE $C800 ******************* R A M   S y m b o l s  ( v a r i a b l e s )
COMMENT_LINE $C800 -------------------
COMMENT_LINE $C800 IN GAME RAM
COMMENT_LINE $C800 -------------------
COMMENT_LINE $C880 statusLineRAM       ds       23                           ; a string containing the remaining ships and the player's score
COMMENT $C880 player's score and the hi score are stored in these 7 bytes!
COMMENT_LINE $C887 HiScore             ds       7                            ; the highest score obtained so far
COMMENT $C887 voice #1
COMMENT $C889 voice #2
COMMENT $C88B voice #3
COMMENT $C88D next three are for sounds on voice #, 2, 3
COMMENT $C890 counter for the background sound playing on voice #2 during space shooter
COMMENT $C892 = 0 , then Tom isn't on the screen, = 1, then he is
COMMENT $C893 location of Tom's space ship or Tom himself on platforms
COMMENT $C896 see below - this just shows which region Tom is in
COMMENT_LINE $C897 bits 1-4    :  What region Tom is currently in (1-3)
COMMENT_LINE $C897 bits 5 - 8  :  open
COMMENT_LINE $C898 bit 1 :  if = 1 then Tom is standing still, facing left
COMMENT_LINE $C898 bit 2 :  if = 1 then Tom is standing still, facing right
COMMENT_LINE $C898 bit 3 :  if = 1 then Tom is running left
COMMENT_LINE $C898 bit 4 :  if = 1 then Tom is running right
COMMENT_LINE $C898 bit 5 :  if = 1 then Tom is ducking while pointed left
COMMENT_LINE $C898 bit 6 :  if = 1 then Tom is ducking while pointed right
COMMENT_LINE $C898 bit 7 :  if = 1 then Tom is climbing the ladder
COMMENT_LINE $C898 bit 8 :  if = 0 then Tom is dead
COMMENT_LINE $C898 if bit 8 and bit 5 are = (total of 9), then Tom ran out of energy.
COMMENT_LINE $C899 starsDim take from $c890 - $c8ad
COMMENT_LINE $C899 starsDim            ds       30                          ; 30 bytes - these are the x,y locations for dimmer stars
COMMENT_LINE $C899 15 stars total, so 30 are needed for each x,y location
COMMENT_LINE $C899 starsBright take from $c8ae - $c8bf
COMMENT_LINE $C899 starsBright         ds       16                          ; 16 bytes - these are the x,y locations for brighter stars
COMMENT_LINE $C899 8 stars total, so 16 are needed for each x,y location
COMMENT $C89A used to draw stars every other frame
COMMENT $C89B used for looping through scrolling stars
COMMENT $C8A2 how long to keep drop fuel explosion on screen
COMMENT_LINE $C8A3 **** begin PowerUp stuff
COMMENT_LINE $C8AC PUBarXStart         ds       1                           ; NOT NEEDED: 9-21-24
COMMENT $C8AC pointer to "SHIELDS" or "GUIDED MISSILE"
COMMENT $C8AF if = 1 then a power up is falling in place of drop fuel
COMMENT $C8B0 if = 1 then a power up is falling in place of drop fuel
COMMENT $C8B1 if != 0 then space ship has a power up! (1=shields, 2=guided missile)
COMMENT $C8B2 this is when the player carries over a power up to Vault
COMMENT_LINE $C8B3 and now he's back in SS...   so load it back in
COMMENT $C8B4 every 5 reductions of the the shield brightess, we reduce the shots bar (strength bar)
COMMENT $C8B5 how bright the shield currently is
COMMENT $C8B6 show the score and ships remaining if this is > 0
COMMENT $C8B7 how many drop fuels are on screen (fuel or power ups)
COMMENT $C8B8 this counts down until it's time to put another drop fuel on screen
COMMENT $C8BA if = 1 then then the power up has alredy been flipped back to Drop Fuel
COMMENT $C8BB if = 1 then then the power up has alredy been flipped back to Drop Fuel
COMMENT $C8C0 used to get it to play the low_fuel_snd 2 times in a row, then back to back ground sounds
COMMENT $C8C1 these two are used to compensate for the shields being on
COMMENT_LINE $C8C3 **** end PowerUp stuff
COMMENT_LINE $C8C3 **** begin intermission stuff
COMMENT $C8C3 if > 0 then we need to start drawing the barrier
COMMENT $C8C4 used for when the space ship door swings open
COMMENT $C8C5 used for when the space ship door swings open
COMMENT $C8C6 each intermission can have multiple sections
COMMENT $C8C7 points to where we are at in shipFlyPattern, if = #255, then it’s overwith
COMMENT $C8C8 where we are in current ship pause
COMMENT $C8C9 0 = normal size thrust, 1 = medium size thrust, 2 = BIG thrust (when Ship is going up)
COMMENT $C8CA points to our movement table: shipFlyPatternX:  where x = 1,2,3,4,5
COMMENT $C8CC for current movement row, how many times do we process this same row?
COMMENT $C8CD if > 0 then we’re opening the door - this represent the door height
COMMENT $C8CE points to our movement table: tomMovePatternX:  where x = 1,2,3,4,5
COMMENT $C8D0 points to where we are at in tomMovePattern, if = #255, then it’s overwith
COMMENT $C8D1 where we are in current tom movement pause
COMMENT_LINE $C8D2 **** end intermission stuff
COMMENT_LINE $C8D2 **** begin enemy collision det padding ****
COMMENT $C8D7 width for top of player ship to enemy
COMMENT $C8D8 width for middle of player ship to enemy
COMMENT $C8D9 width for bottom of player ship to enemy
COMMENT $C8DA how much to pad enemy y coordinate (+ or -)
COMMENT $C8DB how much to pad enemy x coordinate (+ or -)
COMMENT $C8DC the divider of the y-coordinate of the middle of player's ship during coll det with enemy
COMMENT_LINE $C8DD **** end enemy collision det padding ****
COMMENT_LINE $C8DD **** begin enemy missile y and x pad ****
COMMENT $C8DD when putting enemy missile on screen, how much to add or sub to y-coord
COMMENT $C8DE "  "  "  how much to add or sub to x-coord
COMMENT $C8DF if = 1 then if the enemy is too far towards the edge of screen and it's trying to shoot east or west, it will reverse the direction of bullet
COMMENT_LINE $C8E0 **** begin enemy missile y and x pad ****
COMMENT $C8E0 counter in between Tom's footsteps sound being played
COMMENT $C8E1 countdown delay for end of space shooter wave
COMMENT $C8E2 this is the y-coordinate for the final exit ladder - when Tom gets to this, he's completed this platform
COMMENT $C8E3 0 = not on exit ladder, 1 = on exit ladder at bottom of screen, 2 = exit ladder on top of screen
COMMENT $C8E4 a counter to play the Fuel Picked Up sound effect
COMMENT $C8E5 y-coordinate of "F" for Fuel #1
COMMENT $C8E6 x-coordinate of "F" for Fuel #1
COMMENT $C8E7 y-coordinate of "F" for Fuel #2
COMMENT $C8E8 x-coordinate of "F" for Fuel #2
COMMENT $C8E9 total # of "F" fuel pods that will be shown on current platform
COMMENT $C8EB holds the countdown for the next removal of a single Fuel unit in fuel bar
COMMENT $C8EC this hold the duration of the fuel low warning sound
COMMENT $C8EE counter in-between the bird flapping sounds (when Bird is on screen)
COMMENT $C8EF just a generic counter variable
COMMENT $C8F0 just a generic counter variable
COMMENT $C8F1 (platform) will hold the scale value of the exit ladder
COMMENT_LINE $C8F2 ExplScale           ds       1                            ; the scale used for MY_MOVE_TO_D on either space shooter or platform
COMMENT $C8F2 explosion piece 1 y coord
COMMENT $C8F3 explosion piece 2 y coord
COMMENT $C8F4 explosion piece 3 y coord
COMMENT $C8F5 explosion piece 4 y coord
COMMENT $C8F6 explosion piece 1 x coord
COMMENT $C8F7 explosion piece 2 x coord
COMMENT $C8F8 explosion piece 3 x coord
COMMENT $C8F9 explosion piece 4 x coord
COMMENT $C8FA has the size of the Mine Storm explosion for current SS wave/subwave
COMMENT $C8FC explosion counter delay reset value
COMMENT $C8FE explosion pieces animation counter
COMMENT $C900 explosion animattion counter for each of the 4 explosion pieces
COMMENT $C904 piece one's delay in animating the different rotation shapes
COMMENT $C908 y-coord of location of explosion #1
COMMENT $C909 x-coord of location of explosion #1
COMMENT $C90A y-coord of location of explosion #2
COMMENT $C90B x-coord of location of explosion #2
COMMENT $C90C this is the animating exploding pieces
COMMENT_LINE $C90D bit 1 : 0 = explosion 1 is open, 1 = explosion 1 is in use
COMMENT_LINE $C90D bit 2 : 0 = explosion 2 is open, 1 = explosion 2 is in use
COMMENT_LINE $C90D bit 3 : 0 = explosion 3 is open, 1 = explosion 3 is in use
COMMENT_LINE $C90D bit 4 : 0 = explosion #1 is using first explosion sprites, 1 = using second explosion sprites
COMMENT_LINE $C90D bit 5 : 0 = explosion #2 is using first explosion sprites, 1 = using second explosion sprites
COMMENT_LINE $C90D bit 6 : 0 = explosion #3 is using first explosion sprites, 1 = using second explosion sprites
COMMENT_LINE $C90D bit 7 :
COMMENT_LINE $C90D bit 8 :
COMMENT_LINE $C90D explFlags           ds       1                            ; how many minestorm explosions are happening currently
COMMENT $C90F used to scale the "new" Minestorm explosions
COMMENT $C912 just another nmi count as of 9-19-24. Can be used for anything.
COMMENT $C913 Major Tom title screen main countdown (16-bit countdown timer of 10 seconds)
COMMENT_LINE $C915 MTSecs              ds       1                            ; keeps track of total # of seconds we are on title screen
COMMENT $C916 brightness for MAJOR TOM title screen vector
COMMENT $C917 scale for MAJOR TOM title screen vector
COMMENT $C918 attributes for the new Minestorm Explosions #1
COMMENT $C921 attributes for the new Minestorm Explosions #2
COMMENT $C92A attributes for the new Minestorm Explosions #3
COMMENT_LINE $C933 msExpl1Y            ds       1                            ; y-coord of mine storm explosion #1
COMMENT_LINE $C933 msExpl2Y            ds       1                            ; y-coord of mine storm explosion #2
COMMENT_LINE $C933 msExpl3Y            ds       1                            ; y-coord of mine storm explosion #3
COMMENT_LINE $C933 msExpl1X            ds       1                            ; x-coord of mine storm explosion #1
COMMENT_LINE $C933 msExpl2X            ds       1                            ; x-coord of mine storm explosion #2
COMMENT_LINE $C933 msExpl3X            ds       1                            ; x-coord of mine storm explosion #3
COMMENT $C933 store the counter that is used while minestorm explosion sound is playing
COMMENT $C935 if this has a value, then player has died and this is the count down before respawning
COMMENT $C936 used to flag stuff for temp debuggins
COMMENT $C937 used for reg_to_decimal
COMMENT $C938 used for reg_to_decimal
COMMENT $C939 used for reg_to_decimal
COMMENT $C93A used for reg_to_decimal
COMMENT $C93B used for reg_to_decimal
COMMENT $C943 how many bits are currently on screen / which bits are picked up!
COMMENT $C944 direction each bit is going (0=left, 1=right)
COMMENT $C94B tells where we are in the game (title, bonus, game over, platform, space shooter, etc)
COMMENT $C94C How long the game over song jingle plays
COMMENT $C94D the last button player has pressed
COMMENT $C94E a generic countdown timer for an intermission screen
COMMENT $C94F counter to delay in-between playing Space Oddity title song
COMMENT $C951 the next 5 are free to use anywhere
COMMENT $C95A a pointer to a musical definition for DoSound
COMMENT $C95C if a DoSound is playing, this is the countdown for it
COMMENT $C95D how fast everything moves in the game. Starting with Wave #7, it goes 25% faster, after wave #10, it goes 50% faster
COMMENT $C95E how many gun shots Tom has on the gun he picked up
COMMENT $C961 where we are in the jump sequence of good ole Tom
COMMENT $C962 this holds how many enemies are currently on the screen (SS only)
COMMENT $C963 "In Between" counter - a countdown between waves
COMMENT $C966 this is used for intro to Space Shooter: "Wave 1", etc
COMMENT $C967 = to 1 when initEnemies is called
COMMENT $C968 when we encounter an 11 in table, we repeat a certain # times - this keeps track of how many times we've done it thus far
COMMENT $C96B next two are where to place enemy AFTER enemy spawn completes
COMMENT $C96D for each of the "live" enemies, this is the type of enemy
COMMENT_LINE $C970 1 = Machine Champion
COMMENT_LINE $C970 2 = Machine Piper
COMMENT_LINE $C970 3 = Machine Bird
COMMENT_LINE $C970 4 = Machine Star
COMMENT_LINE $C970 5 = Machine Bat
COMMENT $C970 defines the behavior of enemy sprite #1-#5
COMMENT_LINE $C975 Bit 5-8 : points to a shape/movement array (1 = eSprite1, 2 = eSprite2,...)
COMMENT_LINE $C975 Bit 1-4 : value is 1-15 and points to a sprite array of shapes ( 1 = eSprite1, 2 = eSprite2...)
COMMENT $C975 each bit represents something about each enemy
COMMENT_LINE $C976 Bit 1: 1 = enemy #1 is alive
COMMENT_LINE $C976 Bit 2: 1 = enemy #2 is alive
COMMENT_LINE $C976 Bit 3: 1 = enemy #3 is alive
COMMENT_LINE $C976 Bit 4: 1 = enemy #4 is alive
COMMENT_LINE $C976 Bit 5: 1 = enemy #5 is alive
COMMENT_LINE $C976 Bit 6: 1 = enemy #6 is alive
COMMENT_LINE $C976 Bit 7: 1 = enemy #7 is alive
COMMENT_LINE $C976 Bit 8: 1 = enemy #8 is alive
COMMENT_LINE $C977 Bit 1: 1 = enemy #9  is alive
COMMENT_LINE $C977 Bit 2: 1 = enemy #10 is alive
COMMENT_LINE $C977 Bit 3: 1 = enemy #11 is alive
COMMENT_LINE $C977 Bit 4: 1 = enemy #12 is alive
COMMENT_LINE $C977 Bit 5: 1 = enemy #13 is alive
COMMENT_LINE $C977 Bit 6: 1 = enemy #14 is alive
COMMENT_LINE $C977 Bit 7: 1 = enemy #15 is alive
COMMENT_LINE $C977 Bit 8: 1 = enemy #16 is alive
COMMENT $C97C the movement table for each sprite (pointer to a rom location)
COMMENT $C986 points to a sprite table of shapes (1 = eSprite1List, 2 = eSprite2List...)
COMMENT $C990 the # of times to repeat the movement pattern for enemy #1-#5
COMMENT $C995 this is how much to extend the height of the enemy collision detections box (used for the later phases when player is shooting so fast and enemies are moving to fast)
COMMENT $C996 how fast enemy #1-5 moves (higher number = slower movements)
COMMENT_LINE $C99B EnLastShoot         ds       1                            ; the enemy that last shot a missile
COMMENT $C99B if = 1 then bird is on screen, = 0 otherwise
COMMENT $C99C where in the movement array the enemy (#1-5) is currently at (255=attacking mode?)
COMMENT $C9A1 y-coordinate of enemy #1-#15
COMMENT $C9A2 y-coordinate of enemy #1-#15
COMMENT $C9A3 y-coordinate of enemy #1-#15
COMMENT $C9A4 y-coordinate of enemy #1-#15
COMMENT $C9A5 y-coordinate of enemy #1-#15
COMMENT $C9A6 y-coordinate of enemy #1-#15
COMMENT $C9A7 y-coordinate of enemy #1-#15
COMMENT $C9A8 y-coordinate of enemy #1-#15
COMMENT $C9A9 y-coordinate of enemy #1-#15
COMMENT $C9AA y-coordinate of enemy #1-#15
COMMENT $C9AB y-coordinate of enemy #1-#15
COMMENT $C9AC y-coordinate of enemy #1-#15
COMMENT $C9AD y-coordinate of enemy #1-#15
COMMENT $C9AE y-coordinate of enemy #1-#15
COMMENT $C9AF y-coordinate of enemy #1-#15
COMMENT $C9B0 x-coordinate of enemy #1-#5
COMMENT $C9B1 x-coordinate of enemy #1-#5
COMMENT $C9B2 x-coordinate of enemy #1-#5
COMMENT $C9B3 x-coordinate of enemy #1-#5
COMMENT $C9B4 x-coordinate of enemy #1-#5
COMMENT $C9B5 x-coordinate of enemy #1-#5
COMMENT $C9B6 x-coordinate of enemy #1-#5
COMMENT $C9B7 x-coordinate of enemy #1-#5
COMMENT $C9B8 x-coordinate of enemy #1-#5
COMMENT $C9B9 x-coordinate of enemy #1-#5
COMMENT $C9BA x-coordinate of enemy #1-#5
COMMENT $C9BB x-coordinate of enemy #1-#5
COMMENT $C9BC x-coordinate of enemy #1-#5
COMMENT $C9BD x-coordinate of enemy #1-#5
COMMENT $C9BE x-coordinate of enemy #1-#5
COMMENT $C9BF this is a countdown of screen frames in between missile movements (it's the speed of missiles)
COMMENT_LINE $C9CE EnMissCutOff        ds       1                            ; whatever is stored in this var will have the cut off for # of enemy missile to draw on current frame. It depends on WaveMaxBull. If = 4, then this var will be 2.
COMMENT $C9CE if = 1 then the enemy was replenished immediately after being shot
COMMENT $C9CF enemy #1-#5 missile attributes (see below)
COMMENT_LINE $C9D4 bit  1   = 1 then we're using the straight down sprite
COMMENT_LINE $C9D4 bit  2   = 1 then we're using the left diagonal sprite
COMMENT_LINE $C9D4 bit  3   = 1 then we're using the right diagonal sprite
COMMENT_LINE $C9D4 bit  4   = 1 then we're using left or right sprite (due west or due east)
COMMENT_LINE $C9D4 bits 5-8 = the speed of the missile (smaller number makes it move faster)
COMMENT $C9D4 store the counter that is used while recognizer to phase two sound effect
COMMENT $C9D5 this will hold the total # of player bullets that are active (eg: if = 2 then there are two player bullets on screen)
COMMENT $C9D6 how fast the player's bullet will go (depends on what WaveNum he is on)
COMMENT_LINE $C9D7 PlatItems           ds       2                           ; this has the status of all "items" Tom can pick up
COMMENT_LINE $C9D7 bit 1  = if gun #1 is active then 1, else 0
COMMENT_LINE $C9D7 bit 2  = if gun #2 is active then 1, else 0
COMMENT_LINE $C9D7 bit 3  = if power up #1 is active then 1, else 0
COMMENT_LINE $C9D7 bit 4  = if piece #1 is active
COMMENT_LINE $C9D7 bit 5  = if piece #2 is active
COMMENT_LINE $C9D7 bit 6  = if piece #3 is active
COMMENT_LINE $C9D7 bit 7  = if piece #4 is active
COMMENT_LINE $C9D7 bit 8  = if piece #5 is active
COMMENT_LINE $C9D7 bit 9  = if piece #6 is active
COMMENT_LINE $C9D7 bit 10 = if piece #7 is active
COMMENT_LINE $C9D7 bit 11 = if Fuel is active
COMMENT $C9D7 if = 1 then platform enemy is on screen
COMMENT $C9D8 y location to move to in orfer to draw the platform
COMMENT $C9D9 x location to move to in orfer to draw the platform
COMMENT $C9DA .. ... ... draw the second half of the platform
COMMENT $C9DB .. ... ... draw the second half of the platform
COMMENT $C9DC scale used to draw the current level's platform
COMMENT $C9DD this will hold the table of values for the exit ladder (shown when bits are all collected)
COMMENT $C9DF holds the time to show the Platform complete bonus screen
COMMENT $C9E0 this will hold the address location of the platform data (y,x coords of barriers, enemy robots, diamonds, etc)
COMMENT $C9E2 this will hold the address location of the ladder data for each platform level
COMMENT $C9E4 Region 1 of current platform
COMMENT $C9E6 Region 2 of current platform
COMMENT $C9E8 Region 3 of current platform
COMMENT $C9EB = 0 if the Platform Pre-init has not happened, = 1 if it has
COMMENT $C9EC these next two are max left and max right Tom can go to
COMMENT $C9EE this will hold the address location of the gun data for each platform level
COMMENT $C9F4 which platform level Tom is on (1-10...I hope we can get to 10)
COMMENT $C9F5 for a given enemy (in vault) this will hold the number of "stacked"
COMMENT_LINE $C9F8 (overflow) movement tables the active alien has defined (for longer
COMMENT_LINE $C9F8 patterns)
COMMENT $C9F8 if the movement table spans across multiples,
COMMENT_LINE $C9FB this is the number (0,1,2) we are currently on
COMMENT $C9FB for a given vault enemy, this is the pointer to the current sprite movement table (ex: #10 = platSprite11)
COMMENT $C9FE this holds the value for PlatMvNum while a spawn is happening
COMMENT $C9FF this holds the value for PlatNmMvTbl while a spawn is happening
COMMENT $CA00 this holds the value for PlatMvSpNum while a spawn is happening
COMMENT $CA02 while spawn is happening, this holds PlatMovTbl
COMMENT $CA04 for any enemy that is on screen for a Platform level, this points to his movement table (there are some movement tables that span across as many as 5 tables of 127 each)
COMMENT $CA0E if nonzero, thern the shrking of platform playfield ha begun
COMMENT $CA0F during the shrinking of platform sequence, this is a little dealy in b/t each
COMMENT $CA10 which "sub" wave we're on in a Wave for space shooter
COMMENT $CA11 how fast the chase enemies fly towards player ship
COMMENT $CA12 pointer to ChaseSpr1,2,3,4 for the sprite (vector list) shapes for the chase enemy
COMMENT $CA13 maximum # of enemy bullets allowed on screen at once
COMMENT $CA14 holds the maximum number aliens allowed on screen at a time for current wave/subwavenum
COMMENT $CA15 holds the number of enemies remaining that need to be killed to end the wave
COMMENT $CA16 if = 1 then on this WaveNum / SubWaveNum, we suppress drawing the stars to gain some cycles back
COMMENT $CA17 used to show what wave # player is starting in on
COMMENT $CA1E (in the loop) how much to increment Y of the current MISSILE
COMMENT $CA1F (in the loop) how much to increment X of the current MISSILE
COMMENT $CA20 used in processJump to temp store tom's x coord
COMMENT $CA21 used in processJump to temp store tom's x coord
COMMENT $CA22 (space shooter) each each has a different background sound - this points to the sound definition (Arkos Tracker)
COMMENT $CA24 this will hold the address of the Platform playfield definition for the PlatLevel we are on
COMMENT $CA26 second half of platform
COMMENT $CA28 for current platform, this points to the "rules" table for enemies to enter screen
COMMENT $CA2A the rule # of each of the 3 possible enemies on screen are stored here. It's to stop the same rule from getting tripped more than once.
COMMENT $CA2D this holds the last index inserted into RulesInAction array
COMMENT $CA2E this holds the EnemyType of last enemy put on screen
COMMENT $CA2F will hold EnemyM1Info - EnemyM5Info
COMMENT $CA30 whatever level we are on regardless if it's space or platform
COMMENT $CA34 missile speed
COMMENT $CA35 this is read from enemy movement table and if = 1, enemy will fire missile
COMMENT $CA36 (in the loop) how much to increment enemy y-coordinate
COMMENT $CA37 (in the loop) how much to increment enemy x-coordinate
COMMENT $CA38 (in the loop) will hold where enemy is in the movements table
COMMENT $CA39 (in the loop) the speed of the enemy
COMMENT $CA3A (in the loop) where in the movement table's duplicate counter current enemy is at
COMMENT $CA3B (in the loop) 0 = don't fire, any non-zero # is which missile to fire
COMMENT $CA3C used to time the jumping sprite animations
COMMENT $CA3D used to time the animations in Tom running sprites
COMMENT $CA3E attributes that describe Recognizer #1
COMMENT_LINE $CA3F bit 1 : if = to 1 = Recognizer #1 is active
COMMENT_LINE $CA3F bit 2 : if = to 1 = Recognizer #1 is moving left  (x = x - 1)
COMMENT_LINE $CA3F bit 3 : if = to 1 = Recognizer #1 is moving right (x = x + 1)
COMMENT_LINE $CA3F bit 4 : if = to 1 = Recognizer #1 is moving up    (y = y + 1)
COMMENT_LINE $CA3F bit 5 : if = to 1 = Recognizer #1 is moving down  (y = y - 1)
COMMENT_LINE $CA3F bit 6 : if = = 0 then recognizer is in phase #1 (he's on the outer edges waiting to be on same x- axis as player or same y-axis of player)
COMMENT_LINE $CA3F if = = 1 then recognizer is in phase #2 (he's charging towards player and moving much faster)
COMMENT $CA3F attributes that describe Recognizer #2
COMMENT $CA40 attributes that describe Recognizer #3
COMMENT $CA41 how long to wait until putting another recognizer onto screen (set in initPlatform)
COMMENT $CA42 current position in the RecogPause countdown timer
COMMENT $CA43 how long to wait until any recognizers on screen move (set in initPlatform)
COMMENT $CA44 current position in the speed countdown
COMMENT $CA45 total # of Recogs currently on screen
COMMENT $CA46 used in selecting the different Recognizer sprites for animation effect
COMMENT $CA47 current position in RecogAnimCtr for recorgnizer sprites also used in Space Shooter part for countdown of Drop Fuel
COMMENT $CA4E can be 0,8,9   if 8 or 9 we add another recog to screen after fuirst recog is detsroyed
COMMENT_LINE $CA4F timerUsage          ds       2
COMMENT $CA4F these next two are = for the current ladder Tom is on
COMMENT $CA51 hold the # of the last SubWaveNum for this Wave (ex: Wave 1 has 4 sub waves)
COMMENT $CA52 if = 1 then we are on a wave that has boulders or other small squadron enemies
COMMENT $CA53 pointer to the one sprite movement table for Squadron sprites
COMMENT $CA55 pointer to the one sprite shape group for Squadron sprites
COMMENT $CA57 for WaveType=9, this value is used to determine how to do collision detection b/t squad and player's bullet
COMMENT $CA58 for WaveType=9, each enemy has a speed his bullets will go
COMMENT_LINE $CA67 (0=slow, 1=medium, 3 = fast)
COMMENT $CA67 duration of "Warp!" text being on the screen
COMMENT $CA68 y-coord location of the "Warp!" text
COMMENT $CA69 x-coord location of the "Warp!" text
COMMENT $CA6A brightness of the "Warp!" text
COMMENT $CA6B if > 0 then we're in warp mode (Astro Blaster)
COMMENT $CA6C (space shooter) just counts from 49 to 0 - used for the enemy bullet slowdown
COMMENT $CA6D how many enemies have been placed on the screen so far from Squadron
COMMENT $CA6F the next enemy that is on deck to be entering the playfield
COMMENT $CA70 the # of enemies that have a definition (wave1 has 7 enemies defined. each with movement tables, sprite shapes, etc)
COMMENT $CA71 the last enemy # to be killed (this is needed for replacement)
COMMENT $CA72 = 0 then we're on non-squadron enemies, = 9 then we're on squadron enemies
COMMENT $CA73 how long for each enemy to wait before entering the screen
COMMENT_LINE $CA81 WaveEnWait15        ds       1
COMMENT_LINE $CA9D WaveMultiSptr2      ds       26
COMMENT_LINE $CA9D each points to a squadron movement table (used for waves that have the WaveSubDraw populated)
COMMENT $CA9D decides which draw routine to use for enemies in this wave (Draw_VLc or mov_draw_vlc_a)
COMMENT_LINE $CA9E bit 1     : 0 = then use Draw_VLc, 1 = use Mov_Draw_VLc_a
COMMENT_LINE $CA9E bit 2-4   : open
COMMENT_LINE $CA9E bit 5     : 1 = then use the sprite table for each enemy in wave declarations
COMMENT_LINE $CA9E bit 6     : 0 = regular collision detection, 1 = smaller coll det, 3 = smallest
COMMENT $CA9E used for sprite animations (# of animations)
COMMENT $CA9F how many frames to draw before switching animation sprites
COMMENT $CAA0 which frame we currently are on with animations
COMMENT $CAA1 points to a table of all animations to cycle thru
COMMENT $CAA3 (for 3-sprite enemy) points to a sprite table to animate thru
COMMENT $CAA5 which sprite # we are in regarding animation of Squadron sprite
COMMENT $CAA6 this is the EXACT sprite vector list we're drawing when animating 3-sprite enemy
COMMENT $CAA8 (in the loop) the y-coordinate of the current enemy
COMMENT $CAA9 (in the loop) the x-coordinate of the current enemy
COMMENT $CAAA (in the loop) EnemyInfo1, 2, 3, etc is copied into this
COMMENT $CAAB depending on what movement table CurrEnInfo points to, this point to #eSprite1, 2, 3, etc
COMMENT $CAAD will contain a pointer to eSpriteLists (eSprite1List, eSprite2List, etc)
COMMENT $CAAF how fast will Squadron ship shoot (0=slow, 1=medium, 2=fast)
COMMENT $CAB2 each player bullet on the screen can be going left or right on PLATFORM levels
COMMENT_LINE $CAB3 bit 1 = 0 then player bullet #1 is going to the left, 1 = going to the right
COMMENT_LINE $CAB3 bit 2 = 0 then player bullet #2 is going to the left, 1 = going to the right
COMMENT_LINE $CAB3 bit 3 = 0 then player bullet #3 is going to the left, 1 = going to the right
COMMENT_LINE $CAB3 bit 4 = unused
COMMENT_LINE $CAB3 bit 5 = 0 then enemy bullet #1 is going to the left, 1 = going to right
COMMENT_LINE $CAB3 bit 6 = 0 then enemy bullet #2 is going to the left, 1 = going to right
COMMENT_LINE $CAB3 bit 7 = 0 then enemy bullet #3 is going to the left, 1 = going to right
COMMENT_LINE $CAB3 bit 8 = unused
COMMENT $CAB3 used to temporarily store each bullet y coord during the "moving" loop
COMMENT $CAB4 used to temporarily store each bullet x coord during the "moving" loop
COMMENT $CABB = 1 then we picked up a bit that triggered a rule
COMMENT $CABC a counter while the "all_bits_pickedup" sound plays
COMMENT_LINE $CAC1 BitY5               ds       1
COMMENT $CAC9 when Tom has a gun and shoots, this counts down how long the gun shows in his hand
COMMENT $CACA how much to decrement SpawnCounter during spawn or despawn
COMMENT $CACB when to stop the animations
COMMENT $CACC used to check when a Spawn completes - did an enemy (0) or Tom (1) just spawn into place
COMMENT $CACE if > 0 then this represents the enemy that is despawning (from enemyhealth)
COMMENT $CAD1 pointer to where we are in the spawn sounds
COMMENT $CAD2 next two are the location of the spawn which is happening for Tom or enemy
COMMENT $CAD4 when > 0 then we're showing on screen instructions
COMMENT $CAD5 16-bit counter
COMMENT $CAD6 this determines what exactly we are showing re: on screen instructions
COMMENT_LINE $CAD7 1 = showing shoot alients
COMMENT_LINE $CAD7 2 = showing pick up fuel
COMMENT_LINE $CAD7 3 - show getting gun and shooting a machine champ
COMMENT_LINE $CAD7 4 - showing picking up bits and exiting
COMMENT $CAD9 this will be populated when we're playing Space Oddity
COMMENT $CADA will always point to "Space_Oddity_Sng"
COMMENT $CADD generic counter used for many loops
COMMENT $CADF used for Recognizers
COMMENT $CAE0 how many recs are allowed on screen at once (set in initPlatform)
COMMENT $CAE2 used to flag pieces of music being played or not
COMMENT $CAE3 first 4 bits are which level (0-15) the space level player is on and the other 4 bits are which platform level
COMMENT $CAE4 this counter is used to know when to switch player space ship patterns (the phoenix animation)
COMMENT $CAE5 the Gun Shots remaining bar at lower left of Platform screens
COMMENT $CAE6 this is for carrover on how much Power Up (shields or missiles) the player has when leaving SS and going to platformer
COMMENT $CAE7 these next 5 are used for the Gun Shots Remaining bar that appears when Tom has the gun
COMMENT $CAEB each of the eight bits are used s flags (see below)
COMMENT_LINE $CAEC Bit 1 = if 0, the player ship sprite is the big one, else it's the little one
COMMENT_LINE $CAEC Bit 2 = if 1, then player didn't move up or down (used for the ladder climbing logic)
COMMENT_LINE $CAEC = (space shooter) if = 1 then all enemies in a squadron are on the screen
COMMENT_LINE $CAEC Bit 3 = if 1, then we are in Space Shooter, if 0 then we are on platform
COMMENT_LINE $CAEC Bit 4 = if 0, then the Spawn going on is for Tom, if 1, then the current spawn is for enemy (this is used to know what to do when Spawn completes)
COMMENT_LINE $CAEC = (space shooter) if = 1 then Drop Fuel is on screen
COMMENT_LINE $CAEC Bit 5 = (platform) if 1, then we've done the "8" record (first entry) of the movement pattern. 0 means we have not.
COMMENT_LINE $CAEC = (space shooter) if 1, then we've used the Warp for the current ship, 0 = Warp is available
COMMENT_LINE $CAEC Bit 6 = (space shooter) if 0, then we are incrementing first 8 stars
COMMENT_LINE $CAEC = (platform) if 1, then we've used the Warp for the current ship (Tom), 0 = Warp is available
COMMENT_LINE $CAEC Bit 7 = (space shooter) if 0, then we are incrementing second 8 stars
COMMENT_LINE $CAEC Bit 8 = (space shooter) if 0, then we are incrementing third 7 stars
COMMENT_LINE $CAEC 8 4 2 1
COMMENT_LINE $CAEC 1 1 0 1
COMMENT $CAEC used to divide the drawing of enemies in half to be more efficient
COMMENT $CAEF brightness of "PAUSE" text
COMMENT $CAF1 this holds the score player must get for an extra man (5000, 10000, etc...it increments by 5k everytime he gets an extra man)
COMMENT $CAF9 this is for showing the bonus points awarded at end of each platform
COMMENT $CB01 to use YM PLAYER (arkos tracker) you need 166 bytes
COMMENT_LINE $CBA7 RamUsed             ds       1
COMMENT_LINE $CBA7 ***************************************************************************
COMMENT_LINE $CBA7 HEADER SECTION
COMMENT_LINE $CBA7 ***************************************************************************
COMMENT_LINE $CBA7 The cartridge ROM starts at address 0
COMMENT_LINE $0000 for dissi compatability I leave the header in for now!
COMMENT_LINE $0000 the first few bytes are mandatory, otherwise the BIOS will not load
COMMENT_LINE $0000 the ROM file, and will start MineStorm instead
COMMENT $0000 'g' is copyright sign
COMMENT $000B music from the rom
COMMENT $000D hight, width, rel y, rel x (from 0,0)
COMMENT $0011 some game information, ending with $80
COMMENT $001D end of game header
COMMENT_LINE $001E ***************************************************************************
COMMENT_LINE $001E CODE SECTION
COMMENT_LINE $001E ***************************************************************************
COMMENT_LINE $001E init stuff here!!
FORCE_SYMBOL $001E BackGndCtr
FORCE_NO_SYMBOL $0021
FORCE_SYMBOL $0023 Tmp
COMMENT_LINE $0029 .....................................................
COMMENT $0029 bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $0029
FORCE_SYMBOL $002B VIA_int_enable
COMMENT_LINE $002D and now "trigger a interrupt"
COMMENT $002D a VERY short T1 timer
FORCE_NO_SYMBOL $002D
FORCE_SYMBOL $002F VIA_t1_cnt_lo
COMMENT $0032 start timer
FORCE_SYMBOL $0032 VIA_t1_cnt_hi
COMMENT $0034 by the time, the macros "leaves" the interrupt is set!
COMMENT $0036 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $0036
COMMENT $0038 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0038 VIA_DDR_b
COMMENT $003A A = $01, B = 0
FORCE_NO_SYMBOL $003A
COMMENT $003C ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $003C VIA_port_b
FORCE_NO_SYMBOL $003E
COMMENT_LINE $0040 ...........
COMMENT $0040 bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $0040
FORCE_SYMBOL $0042 VIA_int_enable
COMMENT_LINE $0044 and now "trigger a interrupt"
COMMENT $0044 a VERY short T1 timer
FORCE_NO_SYMBOL $0044
FORCE_SYMBOL $0046 VIA_t1_cnt_lo
COMMENT $0049 start timer
FORCE_SYMBOL $0049 VIA_t1_cnt_hi
COMMENT $004B by the time, the macros "leaves" the interrupt is set!
COMMENT $004D Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $004D
COMMENT $004F all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $004F VIA_DDR_b
COMMENT $0051 A = $01, B = 0
FORCE_NO_SYMBOL $0051
COMMENT $0053 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0053 VIA_port_b
FORCE_NO_SYMBOL $0055
COMMENT_LINE $0057 ...........
COMMENT $0057 ensure that shift can generate interrupt
FORCE_NO_SYMBOL $0057
COMMENT_LINE $005A for some reason or another, VIA doesn't like a
COMMENT_LINE $005A std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $005A (only on a real vectrex, not Vide)
FORCE_SYMBOL $005A VIA_aux_cntl
COMMENT $005C and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $005C VIA_shift_reg
COMMENT $005E bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $005E
FORCE_SYMBOL $0060 VIA_int_enable
COMMENT_LINE $0062 wait 20 cycles till store of aux (these are 23)
COMMENT $0062 12
COMMENT $0063 3
FORCE_NO_SYMBOL $0063
FORCE_SYMBOL $0065 VIA_aux_cntl
COMMENT $0067 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $0067
COMMENT $0069 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0069 VIA_DDR_b
COMMENT $006B A = $01, B = 0
FORCE_NO_SYMBOL $006B
COMMENT $006D ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $006D VIA_port_b
FORCE_NO_SYMBOL $006F
COMMENT_LINE $0071 ...........
COMMENT $0071 ensure that shift can generate interrupt
FORCE_NO_SYMBOL $0071
COMMENT_LINE $0074 for some reason or another, VIA doesn't like a
COMMENT_LINE $0074 std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $0074 (only on a real vectrex, not Vide)
FORCE_SYMBOL $0074 VIA_aux_cntl
COMMENT $0076 and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $0076 VIA_shift_reg
COMMENT $0078 bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $0078
FORCE_SYMBOL $007A VIA_int_enable
COMMENT_LINE $007C wait 20 cycles till store of aux (these are 23)
COMMENT $007C 12
COMMENT $007D 3
FORCE_NO_SYMBOL $007D
FORCE_SYMBOL $007F VIA_aux_cntl
COMMENT $0081 Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $0081
COMMENT $0083 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0083 VIA_DDR_b
COMMENT $0085 A = $01, B = 0
FORCE_NO_SYMBOL $0085
COMMENT $0087 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0087 VIA_port_b
FORCE_NO_SYMBOL $0089
COMMENT_LINE $008B ...........
COMMENT $008B ensure that shift can generate interrupt
FORCE_NO_SYMBOL $008B
COMMENT_LINE $008E for some reason or another, VIA doesn't like a
COMMENT_LINE $008E std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $008E (only on a real vectrex, not Vide)
FORCE_SYMBOL $008E VIA_aux_cntl
COMMENT $0090 and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $0090 VIA_shift_reg
COMMENT $0092 bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $0092
FORCE_SYMBOL $0094 VIA_int_enable
COMMENT_LINE $0096 wait 20 cycles till store of aux (these are 23)
COMMENT $0096 12
COMMENT $0097 3
FORCE_NO_SYMBOL $0097
FORCE_SYMBOL $0099 VIA_aux_cntl
COMMENT $009B Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $009B
COMMENT $009D all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $009D VIA_DDR_b
COMMENT $009F A = $01, B = 0
FORCE_NO_SYMBOL $009F
COMMENT $00A1 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $00A1 VIA_port_b
FORCE_NO_SYMBOL $00A3
COMMENT_LINE $00A5 ...........
COMMENT $00A5 ensure that shift can generate interrupt
FORCE_NO_SYMBOL $00A5
COMMENT_LINE $00A8 for some reason or another, VIA doesn't like a
COMMENT_LINE $00A8 std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $00A8 (only on a real vectrex, not Vide)
FORCE_SYMBOL $00A8 VIA_aux_cntl
COMMENT $00AA and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $00AA VIA_shift_reg
COMMENT $00AC bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $00AC
FORCE_SYMBOL $00AE VIA_int_enable
COMMENT_LINE $00B0 wait 20 cycles till store of aux (these are 23)
COMMENT $00B0 12
COMMENT $00B1 3
FORCE_NO_SYMBOL $00B1
FORCE_SYMBOL $00B3 VIA_aux_cntl
COMMENT $00B5 Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $00B5
COMMENT $00B7 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $00B7 VIA_DDR_b
COMMENT $00B9 A = $01, B = 0
FORCE_NO_SYMBOL $00B9
COMMENT $00BB ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $00BB VIA_port_b
FORCE_NO_SYMBOL $00BD
COMMENT_LINE $00BF ...........
COMMENT $00BF bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $00BF
FORCE_SYMBOL $00C1 VIA_int_enable
COMMENT_LINE $00C3 ensure shift is "normal"
COMMENT $00C3 0 = shift,
FORCE_NO_SYMBOL $00C3
FORCE_SYMBOL $00C5 VIA_aux_cntl
COMMENT $00C7 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $00C7
COMMENT $00C9 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $00C9 VIA_DDR_b
COMMENT $00CB A = $01, B = 0
FORCE_NO_SYMBOL $00CB
COMMENT $00CD ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $00CD VIA_port_b
FORCE_NO_SYMBOL $00CF
COMMENT_LINE $00D1 ...........
COMMENT $00D1 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $00D1
FORCE_SYMBOL $00D3 VIA_int_enable
COMMENT_LINE $00D5 ensure shift is "normal"
COMMENT $00D5 0 = shift,
FORCE_NO_SYMBOL $00D5
FORCE_SYMBOL $00D7 VIA_aux_cntl
COMMENT $00D9 Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $00D9
COMMENT $00DB all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $00DB VIA_DDR_b
COMMENT $00DD A = $01, B = 0
FORCE_NO_SYMBOL $00DD
COMMENT $00DF ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $00DF VIA_port_b
FORCE_NO_SYMBOL $00E1
COMMENT_LINE $00E3 ...........
COMMENT $00E3 bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $00E3
FORCE_SYMBOL $00E5 VIA_int_enable
COMMENT_LINE $00E7 and now "trigger a interrupt"
COMMENT $00E7 a VERY short T1 timer
FORCE_NO_SYMBOL $00E7
FORCE_SYMBOL $00E9 VIA_t1_cnt_lo
COMMENT $00EC start timer
FORCE_SYMBOL $00EC VIA_t1_cnt_hi
COMMENT $00EE by the time, the macros "leaves" the interrupt is set!
COMMENT $00F0 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $00F0
COMMENT $00F2 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $00F2 VIA_DDR_b
COMMENT $00F4 A = $01, B = 0
FORCE_NO_SYMBOL $00F4
COMMENT $00F6 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $00F6 VIA_port_b
FORCE_NO_SYMBOL $00F8
COMMENT $00FA Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $00FA
COMMENT $00FC all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $00FC VIA_DDR_b
COMMENT $00FE A = $01, B = 0
FORCE_NO_SYMBOL $00FE
COMMENT $0100 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0100 VIA_port_b
COMMENT $0102 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $0102
FORCE_SYMBOL $0104 VIA_int_enable
COMMENT_LINE $0106 ensure shift is "normal"
COMMENT $0106 0 = shift,
FORCE_NO_SYMBOL $0106
FORCE_SYMBOL $0108 VIA_aux_cntl
COMMENT_LINE $010B ...........
COMMENT $010B ensure that shift can generate interrupt
FORCE_NO_SYMBOL $010B
COMMENT_LINE $010E for some reason or another, VIA doesn't like a
COMMENT_LINE $010E std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $010E (only on a real vectrex, not Vide)
FORCE_SYMBOL $010E VIA_aux_cntl
COMMENT $0110 and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $0110 VIA_shift_reg
COMMENT $0112 bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $0112
FORCE_SYMBOL $0114 VIA_int_enable
COMMENT_LINE $0116 wait 20 cycles till store of aux (these are 23)
COMMENT $0116 12
COMMENT $0117 3
FORCE_NO_SYMBOL $0117
FORCE_SYMBOL $0119 VIA_aux_cntl
COMMENT $011B Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $011B
COMMENT $011D all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $011D VIA_DDR_b
COMMENT $011F A = $01, B = 0
FORCE_NO_SYMBOL $011F
COMMENT $0121 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0121 VIA_port_b
FORCE_NO_SYMBOL $0123
COMMENT $0125 Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $0125
COMMENT $0127 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0127 VIA_DDR_b
COMMENT $0129 A = $01, B = 0
FORCE_NO_SYMBOL $0129
COMMENT $012B ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $012B VIA_port_b
COMMENT $012D bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $012D
FORCE_SYMBOL $012F VIA_int_enable
COMMENT_LINE $0131 ensure shift is "normal"
COMMENT $0131 0 = shift,
FORCE_NO_SYMBOL $0131
FORCE_SYMBOL $0133 VIA_aux_cntl
COMMENT_LINE $0136 ...........
COMMENT_LINE $0136 PB6 stays
COMMENT $0136 bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $0136
FORCE_SYMBOL $0138 VIA_int_enable
COMMENT_LINE $013A and now "trigger a interrupt"
COMMENT $013A a VERY short T1 timer
FORCE_NO_SYMBOL $013A
FORCE_SYMBOL $013C VIA_t1_cnt_lo
COMMENT $013F start timer
FORCE_SYMBOL $013F VIA_t1_cnt_hi
COMMENT $0141 by the time, the macros "leaves" the interrupt is set!
FORCE_NO_SYMBOL $0143
COMMENT $0145 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $0145
FORCE_SYMBOL $0147 VIA_int_enable
COMMENT_LINE $0149 ensure shift is "normal"
COMMENT $0149 0 = shift,
FORCE_NO_SYMBOL $0149
FORCE_SYMBOL $014B VIA_aux_cntl
COMMENT_LINE $014E ...........
COMMENT_LINE $014E PB6 stays
COMMENT $014E ensure that shift can generate interrupt
FORCE_NO_SYMBOL $014E
COMMENT_LINE $0151 for some reason or another, VIA doesn't like a
COMMENT_LINE $0151 std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $0151 (only on a real vectrex, not Vide)
FORCE_SYMBOL $0151 VIA_aux_cntl
COMMENT $0153 and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $0153 VIA_shift_reg
COMMENT $0155 bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $0155
FORCE_SYMBOL $0157 VIA_int_enable
COMMENT_LINE $0159 wait 20 cycles till store of aux (these are 23)
COMMENT $0159 12
COMMENT $015A 3
FORCE_NO_SYMBOL $015A
FORCE_SYMBOL $015C VIA_aux_cntl
FORCE_NO_SYMBOL $015E
COMMENT $0160 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $0160
FORCE_SYMBOL $0162 VIA_int_enable
COMMENT_LINE $0164 ensure shift is "normal"
COMMENT $0164 0 = shift,
FORCE_NO_SYMBOL $0164
FORCE_SYMBOL $0166 VIA_aux_cntl
COMMENT_LINE $0169 ...........
COMMENT $0169 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $0169
COMMENT $016B all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $016B VIA_DDR_b
COMMENT $016D A = $01, B = 0
FORCE_NO_SYMBOL $016D
COMMENT $016F ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $016F VIA_port_b
FORCE_NO_SYMBOL $0171
COMMENT $0173 Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $0173
COMMENT $0175 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0175 VIA_DDR_b
COMMENT $0177 A = $01, B = 0
FORCE_NO_SYMBOL $0177
COMMENT $0179 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0179 VIA_port_b
COMMENT_LINE $017C ...........
COMMENT $017C Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $017C
COMMENT $017E all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $017E VIA_DDR_b
COMMENT $0180 A = $01, B = 0
FORCE_NO_SYMBOL $0180
COMMENT $0182 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0182 VIA_port_b
FORCE_NO_SYMBOL $0184
COMMENT $0186 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $0186
COMMENT $0188 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0188 VIA_DDR_b
COMMENT $018A A = $01, B = 0
FORCE_NO_SYMBOL $018A
COMMENT $018C ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $018C VIA_port_b
COMMENT_LINE $018F ...........
COMMENT $018F bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $018F
FORCE_SYMBOL $0191 VIA_int_enable
COMMENT_LINE $0193 and now "trigger a interrupt"
COMMENT $0193 a VERY short T1 timer
FORCE_NO_SYMBOL $0193
FORCE_SYMBOL $0195 VIA_t1_cnt_lo
COMMENT $0198 start timer
FORCE_SYMBOL $0198 VIA_t1_cnt_hi
COMMENT $019A by the time, the macros "leaves" the interrupt is set!
FORCE_NO_SYMBOL $019C
COMMENT $019E bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $019E
FORCE_SYMBOL $01A0 VIA_int_enable
COMMENT_LINE $01A2 ensure shift is "normal"
COMMENT $01A2 0 = shift,
FORCE_NO_SYMBOL $01A2
FORCE_SYMBOL $01A4 VIA_aux_cntl
COMMENT_LINE $01A7 ...........
COMMENT $01A7 ensure that shift can generate interrupt
FORCE_NO_SYMBOL $01A7
COMMENT_LINE $01AA for some reason or another, VIA doesn't like a
COMMENT_LINE $01AA std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $01AA (only on a real vectrex, not Vide)
FORCE_SYMBOL $01AA VIA_aux_cntl
COMMENT $01AC and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $01AC VIA_shift_reg
COMMENT $01AE bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $01AE
FORCE_SYMBOL $01B0 VIA_int_enable
COMMENT_LINE $01B2 wait 20 cycles till store of aux (these are 23)
COMMENT $01B2 12
COMMENT $01B3 3
FORCE_NO_SYMBOL $01B3
FORCE_SYMBOL $01B5 VIA_aux_cntl
FORCE_NO_SYMBOL $01B7
COMMENT $01B9 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $01B9
FORCE_SYMBOL $01BB VIA_int_enable
COMMENT_LINE $01BD ensure shift is "normal"
COMMENT $01BD 0 = shift,
FORCE_NO_SYMBOL $01BD
FORCE_SYMBOL $01BF VIA_aux_cntl
COMMENT_LINE $01C2 ...........
COMMENT $01C2 bit 7 = 1, each other "1" sets the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $01C2
FORCE_SYMBOL $01C4 VIA_int_enable
COMMENT_LINE $01C6 and now "trigger a interrupt"
COMMENT $01C6 a VERY short T1 timer
FORCE_NO_SYMBOL $01C6
FORCE_SYMBOL $01C8 VIA_t1_cnt_lo
COMMENT $01CB start timer
FORCE_SYMBOL $01CB VIA_t1_cnt_hi
COMMENT $01CD by the time, the macros "leaves" the interrupt is set!
COMMENT $01CF Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $01CF
COMMENT $01D1 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $01D1 VIA_DDR_b
COMMENT $01D3 A = $01, B = 0
FORCE_NO_SYMBOL $01D3
COMMENT $01D5 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $01D5 VIA_port_b
FORCE_NO_SYMBOL $01D7
COMMENT $01D9 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $01D9
COMMENT $01DB all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $01DB VIA_DDR_b
COMMENT $01DD A = $01, B = 0
FORCE_NO_SYMBOL $01DD
COMMENT $01DF ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $01DF VIA_port_b
COMMENT $01E1 bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $01E1
FORCE_SYMBOL $01E3 VIA_int_enable
COMMENT_LINE $01E5 ensure shift is "normal"
COMMENT $01E5 0 = shift,
FORCE_NO_SYMBOL $01E5
FORCE_SYMBOL $01E7 VIA_aux_cntl
COMMENT_LINE $01EA ...........
COMMENT $01EA ensure that shift can generate interrupt
FORCE_NO_SYMBOL $01EA
COMMENT_LINE $01ED for some reason or another, VIA doesn't like a
COMMENT_LINE $01ED std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $01ED (only on a real vectrex, not Vide)
FORCE_SYMBOL $01ED VIA_aux_cntl
COMMENT $01EF and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $01EF VIA_shift_reg
COMMENT $01F1 bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $01F1
FORCE_SYMBOL $01F3 VIA_int_enable
COMMENT_LINE $01F5 wait 20 cycles till store of aux (these are 23)
COMMENT $01F5 12
COMMENT $01F6 3
FORCE_NO_SYMBOL $01F6
FORCE_SYMBOL $01F8 VIA_aux_cntl
COMMENT $01FA Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $01FA
COMMENT $01FC all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $01FC VIA_DDR_b
COMMENT $01FE A = $01, B = 0
FORCE_NO_SYMBOL $01FE
COMMENT $0200 ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $0200 VIA_port_b
FORCE_NO_SYMBOL $0202
COMMENT $0204 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $0204
COMMENT $0206 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0206 VIA_DDR_b
COMMENT $0208 A = $01, B = 0
FORCE_NO_SYMBOL $0208
COMMENT $020A ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $020A VIA_port_b
COMMENT $020C bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $020C
FORCE_SYMBOL $020E VIA_int_enable
COMMENT_LINE $0210 ensure shift is "normal"
COMMENT $0210 0 = shift,
FORCE_NO_SYMBOL $0210
FORCE_SYMBOL $0212 VIA_aux_cntl
COMMENT_LINE $0215 ...........
COMMENT $0215 Prepare DDR Registers % 1101 1111 1111 1111
FORCE_NO_SYMBOL $0215
COMMENT $0217 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0217 VIA_DDR_b
COMMENT $0219 A = $01, B = 0
FORCE_NO_SYMBOL $0219
COMMENT $021B ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $021B VIA_port_b
COMMENT $021D bit 7 = 0, each other "1" clears the IEflag, bit 6 = T1
FORCE_NO_SYMBOL $021D
FORCE_SYMBOL $021F VIA_int_enable
COMMENT_LINE $0221 ensure shift is "normal"
COMMENT $0221 0 = shift,
FORCE_NO_SYMBOL $0221
FORCE_SYMBOL $0223 VIA_aux_cntl
COMMENT $0226 ensure that shift can generate interrupt
FORCE_NO_SYMBOL $0226
COMMENT_LINE $0229 for some reason or another, VIA doesn't like a
COMMENT_LINE $0229 std VIA_shift_reg, Bankswitching (IRQ?) than crashes!
COMMENT_LINE $0229 (only on a real vectrex, not Vide)
FORCE_SYMBOL $0229 VIA_aux_cntl
COMMENT $022B and write 0 to shift (a) and $98 to aux (shift out enable)
FORCE_SYMBOL $022B VIA_shift_reg
COMMENT $022D bit 7 = 1, each other "1" enables interrupts(bit 6 = t1, bit 2 = shift), both enabled
FORCE_NO_SYMBOL $022D
FORCE_SYMBOL $022F VIA_int_enable
COMMENT_LINE $0231 wait 20 cycles till store of aux (these are 23)
COMMENT $0231 12
COMMENT $0232 3
FORCE_NO_SYMBOL $0232
FORCE_SYMBOL $0234 VIA_aux_cntl
COMMENT $0236 Prepare DDR Registers % 1001 1111 1111 1111
FORCE_NO_SYMBOL $0236
COMMENT $0238 all ORB/ORA to output except ORB 5, PB6 goes LOW
FORCE_SYMBOL $0238 VIA_DDR_b
COMMENT $023A A = $01, B = 0
FORCE_NO_SYMBOL $023A
COMMENT $023C ORB = $1 (ramp on, mux off), ORA = 0 (DAC)
FORCE_SYMBOL $023C VIA_port_b
FORCE_NO_SYMBOL $023E
COMMENT_LINE $0240 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0240 following is needed for VIDE
COMMENT_LINE $0240 to replace "vars" in this bank with values from the other bank
COMMENT_LINE $0240 #genVarlist# varFromBank2
COMMENT_LINE $0240 ***************************************************************************
COMMENT_LINE $0240 CODE SECTION
COMMENT_LINE $0240 ***************************************************************************
COMMENT $0242 Vectrex BIOS recalibration
FORCE_SYMBOL $0242 Wait_Recal
COMMENT $0245 Sets the intensitdddddy of the
FORCE_SYMBOL $0245 Intensity_5F
COMMENT_LINE $0248 vector beam to $5f
FORCE_SYMBOL $0248 playSound
COMMENT $024B scalefactor
FORCE_NO_SYMBOL $024B
FORCE_SYMBOL $024D VIA_t1_cnt_lo
COMMENT $024F position relative Y
FORCE_NO_SYMBOL $024F
COMMENT $0251 position relative X
FORCE_NO_SYMBOL $0251
COMMENT $0253 sets up VIA control register after a wait recal
FORCE_SYMBOL $0253 Moveto_d
COMMENT $0256 address of string
FORCE_SYMBOL $0256 EnemyTwo
COMMENT $0259 Vectrex BIOS print routine
FORCE_SYMBOL $0259 Draw_VLc
FORCE_SYMBOL $025C Reset0Ref
FORCE_SYMBOL $025F printBankString
FORCE_SYMBOL $0262 Read_Btns
FORCE_SYMBOL $0268 BackGndCtr
COMMENT_LINE $026B this jumps to the main label in bank #3
FORCE_NO_SYMBOL $026B
FORCE_SYMBOL $026E jmpBank3
COMMENT_LINE $0273 ***************************************************************************
FORCE_SYMBOL $0276 Vec_Text_HW
FORCE_SYMBOL $0279 bank_string1
FORCE_SYMBOL $0280 Print_Str_d
FORCE_SYMBOL $0283 bank_string2
FORCE_SYMBOL $028A Print_Str_d
COMMENT_LINE $028E ***************************************************************************
COMMENT $02A8 number of lines to draw
COMMENT $02A9 draw to y, x
COMMENT $02AB draw to y, x
COMMENT $02AD draw to y, x
COMMENT $02AF draw to y, x
COMMENT $02B1 draw to y, x
COMMENT $02B3 draw to y, x
COMMENT $02B5 draw to y, x
COMMENT $02B7 draw to y, x
COMMENT_LINE $02B9 uses 166 byte RAM!
COMMENT_LINE $CB01 ds   780
COMMENT_LINE $02B9 ***************************************************************************
COMMENT_LINE $02B9 ***************************************************************************
COMMENT $02B9 load current VBL Counter
FORCE_SYMBOL $02B9 ym_data_current
COMMENT $02BC if 0, than we are done
COMMENT $02BE otherwise remember we are doing one byte now
FORCE_NO_SYMBOL $02BE
COMMENT $02C1 and store it
FORCE_SYMBOL $02C1 ym_data_current
COMMENT $02C4 get the number of regs we are working on
FORCE_SYMBOL $02C4 ym_regs_used
COMMENT $02C7 and remember them as current counter
FORCE_SYMBOL $02C7 ym_regs_count
COMMENT $02CA load RAM start address of our wokring structure
FORCE_SYMBOL $02CA ym_data_start
COMMENT $02CD in relation to RAM structure (U), get the next register byte
FORCE_SYMBOL $02CD get_cbyte
COMMENT $02D0 load current register
FORCE_SYMBOL $02D0 REG_USED
COMMENT_LINE $02D2 A PSG reg
COMMENT_LINE $02D2 B data
COMMENT $02D2 and actually output that to the sound chip
FORCE_SYMBOL $02D2 Sound_Byte
COMMENT $02D5 go to next "register" of sound data
FORCE_SYMBOL $02D5 STRUCT_LEN
COMMENT $02D7 but only if we are not done yet, if counter is zero
FORCE_SYMBOL $02D7 ym_regs_count
COMMENT $02DA we do not branch :-)
COMMENT_LINE $02DD no we must look at the bits
COMMENT_LINE $02DD a will be our bit register
COMMENT_LINE $02DD ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $02DD BIT_POS
COMMENT_LINE $02E1 load a new byte
FORCE_SYMBOL $02E1 BYTE_POS
FORCE_SYMBOL $02E5 CBYTE
FORCE_SYMBOL $02E7 BYTE_POS
FORCE_NO_SYMBOL $02E9
FORCE_SYMBOL $02EB BIT_POS
COMMENT_LINE $02ED bit position correct here
COMMENT_LINE $02ED remember we use one bit now!
FORCE_SYMBOL $02ED BIT_POS
COMMENT_LINE $02EF is the bit at the current position set?
FORCE_SYMBOL $02EF CBYTE
COMMENT_LINE $02F1 ;;;;;;;;;;;;;;;;;; GET_BIT END
COMMENT_LINE $02F1 zero flag show bit
COMMENT_LINE $02F1 A is 1 or zero
COMMENT_LINE $02F5 must be zero
COMMENT_LINE $02F5 1 is allways only 8 bit...
FORCE_SYMBOL $02F7 calc_bits
FORCE_SYMBOL $02FA calc_coder
FORCE_SYMBOL $02FD calc_coder
COMMENT $0300 increase used bits
FORCE_SYMBOL $0300 calc_bits
COMMENT_LINE $0303 ;;;;;;;;;;; GET_BIT_START
FORCE_SYMBOL $0303 BIT_POS
COMMENT_LINE $0307 load a new byte
FORCE_SYMBOL $0307 BYTE_POS
FORCE_SYMBOL $030B CBYTE
FORCE_SYMBOL $030D BYTE_POS
FORCE_NO_SYMBOL $030F
FORCE_SYMBOL $0311 BIT_POS
COMMENT_LINE $0313 bit position correct here
COMMENT_LINE $0313 remember we use one bit now!
FORCE_SYMBOL $0313 BIT_POS
COMMENT_LINE $0315 is the bit at the current position set?
FORCE_SYMBOL $0315 CBYTE
COMMENT $0317 and if non zero
FORCE_SYMBOL $0319 calc_coder
COMMENT_LINE $031C ;;;;;;;;;;; GET_BIT_END
COMMENT_LINE $031C we load one complete = of mapper index, bits, coder, map-value
FORCE_SYMBOL $031C CRLE_MAPPER
FORCE_NO_SYMBOL $031E
COMMENT $0320 load bits from map
FORCE_NO_SYMBOL $0320
COMMENT $0322 map out phrases
FORCE_NO_SYMBOL $0322
COMMENT $0324 neu
FORCE_SYMBOL $0324 calc_bits
COMMENT $0327 neu
COMMENT $032B load coder-byte
FORCE_NO_SYMBOL $032B
FORCE_SYMBOL $032D calc_coder
COMMENT $0332 load current mapped byte!
FORCE_NO_SYMBOL $0332
COMMENT_LINE $0334 in b is the byte value we sought
COMMENT_LINE $0334 test for phrase
COMMENT $0334 load bits from map
FORCE_NO_SYMBOL $0334
COMMENT $0336 map in phrases only
FORCE_NO_SYMBOL $0336
COMMENT_LINE $033A if phrase, than in b the count of the phrase used
FORCE_SYMBOL $033A CP_START
FORCE_SYMBOL $0346 CIS_PHRASE
FORCE_SYMBOL $0348 CP_BYTE
FORCE_SYMBOL $034C CIS_PHRASE
FORCE_SYMBOL $0350 CU_BYTE
COMMENT_LINE $0352 U pointer to data structure
COMMENT_LINE $0352 A number of register
COMMENT_LINE $0352 do we have a byte that is valid?
FORCE_SYMBOL $0352 CRLE_COUNTER
COMMENT_LINE $0356 yep... use current byte
FORCE_SYMBOL $0356 CIS_PHRASE
COMMENT $035A length of phrase
FORCE_SYMBOL $035C CP_BYTE
COMMENT $035E this is the current byte
FORCE_SYMBOL $0360 CU_BYTE
FORCE_SYMBOL $0362 CP_BYTE
FORCE_SYMBOL $0364 CP_BYTE
FORCE_SYMBOL $0368 CP_BYTE
FORCE_SYMBOL $036A CRLE_COUNTER
FORCE_NO_SYMBOL $036C
FORCE_SYMBOL $036F CRLE_COUNTER
FORCE_SYMBOL $0371 CU_BYTE
COMMENT_LINE $0374 non single byte here... must decode
COMMENT_LINE $0374 first we look for how many bits the RLE counter spreads
COMMENT_LINE $0374 we already encountered a 1
COMMENT_LINE $0374 and we allways use + 2
FORCE_NO_SYMBOL $0374
FORCE_SYMBOL $0376 temp
FORCE_SYMBOL $0379 temp
COMMENT_LINE $037C ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $037C BIT_POS
COMMENT_LINE $0380 load a new byte
FORCE_SYMBOL $0380 BYTE_POS
FORCE_SYMBOL $0384 CBYTE
FORCE_SYMBOL $0386 BYTE_POS
FORCE_NO_SYMBOL $0388
FORCE_SYMBOL $038A BIT_POS
COMMENT_LINE $038C bit position correct here
COMMENT_LINE $038C remember we use one bit now!
FORCE_SYMBOL $038C BIT_POS
COMMENT_LINE $038E is the bit at the current position set?
FORCE_SYMBOL $038E CBYTE
COMMENT_LINE $0390 ;;;;;;;;;;;;;;;;;; GET_BIT END
COMMENT_LINE $0392 in temp is the # of bits for the counter
COMMENT_LINE $0392 the following '#temp' bits represent the RLE count
COMMENT_LINE $0392 lsb first
COMMENT $0392 we start at 1, since zero is an
COMMENT_LINE $0393 'own' 'subroutine',
COMMENT_LINE $0393 which doesn't manipulate the temps
COMMENT $0393 bit counter for shifting
FORCE_SYMBOL $0393 temp2
COMMENT $0396 bit counter for shifting
FORCE_SYMBOL $0396 temp3
COMMENT_LINE $0399 ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $0399 BIT_POS
COMMENT_LINE $039D load a new byte
FORCE_SYMBOL $039D BYTE_POS
FORCE_SYMBOL $03A1 CBYTE
FORCE_SYMBOL $03A3 BYTE_POS
FORCE_NO_SYMBOL $03A5
FORCE_SYMBOL $03A7 BIT_POS
COMMENT_LINE $03A9 bit position correct here
COMMENT_LINE $03A9 remember we use one bit now!
FORCE_SYMBOL $03A9 BIT_POS
COMMENT_LINE $03AB is the bit at the current position set?
FORCE_SYMBOL $03AB CBYTE
COMMENT_LINE $03AF return 1
FORCE_NO_SYMBOL $03AF
COMMENT_LINE $03B1 ;;;;;;;;;;;;;;;;;; GET_BIT END
COMMENT_LINE $03B1 in D now one bit at the right position for the RLE counter
COMMENT_LINE $03B3 the first 3 (here only the first one) rounds
COMMENT_LINE $03B3 we need not check for temp, since it is at least 3...
COMMENT_LINE $03B3 ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $03B3 BIT_POS
COMMENT_LINE $03B7 load a new byte
FORCE_SYMBOL $03B7 BYTE_POS
FORCE_SYMBOL $03BB CBYTE
FORCE_SYMBOL $03BD BYTE_POS
FORCE_NO_SYMBOL $03BF
FORCE_SYMBOL $03C1 BIT_POS
COMMENT_LINE $03C3 bit position correct here
COMMENT_LINE $03C3 remember we use one bit now!
FORCE_SYMBOL $03C3 BIT_POS
COMMENT_LINE $03C5 is the bit at the current position set?
FORCE_SYMBOL $03C5 CBYTE
COMMENT_LINE $03C9 return 1
FORCE_NO_SYMBOL $03C9
COMMENT $03CC LSR A
COMMENT $03CD LSR B
COMMENT $03CE if no carry, than exit
COMMENT $03D0 otherwise underflow from A to 7bit of B
FORCE_NO_SYMBOL $03D0
FORCE_SYMBOL $03D2 temp3
COMMENT_LINE $03D7 in D now one bit at the right position for the RLE counter
FORCE_SYMBOL $03D7 CRLE_COUNTER
FORCE_SYMBOL $03D9 CRLE_COUNTER
FORCE_SYMBOL $03DB temp2
FORCE_SYMBOL $03DE temp2
FORCE_SYMBOL $03E1 temp3
FORCE_SYMBOL $03E4 temp
COMMENT_LINE $03E9 now the current counter should be set
COMMENT_LINE $03E9 we still need to dechifer the following byte...
FORCE_SYMBOL $03E9 dechifer
COMMENT $03EC load start address of ram buffer for YM play
FORCE_SYMBOL $03EC ym_data_start
COMMENT $03EF load length of buffer
COMMENT $03F2 clear buffer
FORCE_SYMBOL $03F2 Clear_x_d
COMMENT $03F5 count of registers that are used by the player - reset
FORCE_SYMBOL $03F5 ym_regs_used
COMMENT $03F8 first load start of all data to y
COMMENT $03FB load vbl_len to d
FORCE_NO_SYMBOL $03FB
COMMENT $03FD and store it to len reset
FORCE_SYMBOL $03FD ym_len
COMMENT $0400 and store it to current data pointer
FORCE_SYMBOL $0400 ym_data_current
COMMENT $0403 load number of next register to work on
COMMENT $0405 count the registers we actually use
FORCE_SYMBOL $0405 ym_regs_used
COMMENT $0408 and store the register of the current data
FORCE_SYMBOL $0408 REG_USED
COMMENT $040A load location of translation map to y
COMMENT $040D and store it
FORCE_SYMBOL $040D CRLE_MAPPER
COMMENT $0410 load location of phrases
COMMENT $0413 and store it
FORCE_SYMBOL $0413 CP_START
COMMENT $0416 load location of RLE data
COMMENT $0419 and store it
FORCE_SYMBOL $0419 BYTE_POS
COMMENT $041C add structure length to x
FORCE_SYMBOL $041C STRUCT_LEN
COMMENT $041E load number of next register to work on
COMMENT $0420 if negative than we are done
FORCE_SYMBOL $0422 ym_name
COMMENT $0426 vbl_len
COMMENT_LINE $0428 translation data
COMMENT_LINE $0428 DB $15; bytes follow
COMMENT_LINE $0428 bits used, code, real 'byte'
COMMENT $0428 288
COMMENT $042B 3
COMMENT $042E 3
COMMENT $0431 3
COMMENT $0434 3
COMMENT $0437 3
COMMENT $043A 3
COMMENT $043D 3
COMMENT $0440 3
COMMENT $0443 3
COMMENT $0446 3
COMMENT $0449 3
COMMENT $044C 3
COMMENT $044F 3
COMMENT $0452 3
COMMENT $0455 3
COMMENT $0458 3
COMMENT $045B 3
COMMENT $045E 3
COMMENT $0461 3
COMMENT $0464 3
COMMENT_LINE $0467 phrases follow
COMMENT_LINE $0467 data follows
COMMENT $047B flushed
COMMENT_LINE $0484 translation data
COMMENT_LINE $0484 DB $01; bytes follow
COMMENT_LINE $0484 bits used, code, real 'byte'
COMMENT $0484 348
COMMENT_LINE $0487 phrases follow
COMMENT_LINE $0487 data follows
COMMENT $0487 flushed
COMMENT_LINE $048A translation data
COMMENT_LINE $048A DB $20; bytes follow
COMMENT_LINE $048A bits used, code, real 'byte'
COMMENT $048A 196
COMMENT $048D 58
COMMENT $0490 4
COMMENT $0493 8
COMMENT $0496 8
COMMENT $0499 3
COMMENT $049C 3
COMMENT $049F 3
COMMENT $04A2 3
COMMENT $04A5 4
COMMENT $04A8 4
COMMENT $04AB 4
COMMENT $04AE 4
COMMENT $04B1 4
COMMENT $04B4 2
COMMENT $04B7 3
COMMENT $04BA 3
COMMENT $04BD 3
COMMENT $04C0 3
COMMENT $04C3 3
COMMENT $04C6 3
COMMENT $04C9 3
COMMENT $04CC 3
COMMENT $04CF 3
COMMENT $04D2 3
COMMENT $04D5 3
COMMENT $04D8 3
COMMENT $04DB 4
COMMENT $04DE 4
COMMENT $04E1 4
COMMENT $04E4 4
COMMENT $04E7 2
COMMENT_LINE $04EA phrases follow
COMMENT $04EA 196
COMMENT_LINE $04F9 data follows
COMMENT $053F flushed
COMMENT_LINE $0541 translation data
COMMENT_LINE $0541 DB $09; bytes follow
COMMENT_LINE $0541 bits used, code, real 'byte'
COMMENT $0541 196
COMMENT $0544 110
COMMENT $0547 8
COMMENT $054A 6
COMMENT $054D 8
COMMENT $0550 8
COMMENT $0553 8
COMMENT $0556 14
COMMENT $0559 4
COMMENT_LINE $055C phrases follow
COMMENT $055C 196
COMMENT_LINE $056B data follows
COMMENT $0593 flushed
COMMENT_LINE $0598 translation data
COMMENT_LINE $0598 DB $15; bytes follow
COMMENT_LINE $0598 bits used, code, real 'byte'
COMMENT $0598 288
COMMENT $059B 3
COMMENT $059E 3
COMMENT $05A1 3
COMMENT $05A4 3
COMMENT $05A7 3
COMMENT $05AA 3
COMMENT $05AD 3
COMMENT $05B0 3
COMMENT $05B3 3
COMMENT $05B6 3
COMMENT $05B9 3
COMMENT $05BC 3
COMMENT $05BF 3
COMMENT $05C2 3
COMMENT $05C5 3
COMMENT $05C8 3
COMMENT $05CB 3
COMMENT $05CE 3
COMMENT $05D1 3
COMMENT $05D4 3
COMMENT_LINE $05D7 phrases follow
COMMENT_LINE $05D7 data follows
COMMENT $05EB flushed
COMMENT_LINE $05F4 translation data
COMMENT_LINE $05F4 DB $01; bytes follow
COMMENT_LINE $05F4 bits used, code, real 'byte'
COMMENT $05F4 348
COMMENT_LINE $05F7 phrases follow
COMMENT_LINE $05F7 data follows
COMMENT $05F7 flushed
COMMENT_LINE $05FA translation data
COMMENT_LINE $05FA DB $01; bytes follow
COMMENT_LINE $05FA bits used, code, real 'byte'
COMMENT $05FA 348
COMMENT_LINE $05FD phrases follow
COMMENT_LINE $05FD data follows
COMMENT $05FD flushed
COMMENT_LINE $0600 translation data
COMMENT_LINE $0600 DB $02; bytes follow
COMMENT_LINE $0600 bits used, code, real 'byte'
COMMENT $0600 285
COMMENT $0603 63
COMMENT_LINE $0606 phrases follow
COMMENT_LINE $0606 data follows
COMMENT $0606 flushed
COMMENT_LINE $060A translation data
COMMENT_LINE $060A DB $0A; bytes follow
COMMENT_LINE $060A bits used, code, real 'byte'
COMMENT $060A 285
COMMENT $060D 12
COMMENT $0610 6
COMMENT $0613 15
COMMENT $0616 15
COMMENT $0619 3
COMMENT $061C 3
COMMENT $061F 3
COMMENT $0622 3
COMMENT $0625 3
COMMENT_LINE $0628 phrases follow
COMMENT_LINE $0628 data follows
COMMENT $0632 flushed
COMMENT_LINE $0636 translation data
COMMENT_LINE $0636 DB $0A; bytes follow
COMMENT_LINE $0636 bits used, code, real 'byte'
COMMENT $0636 60
COMMENT $0639 118
COMMENT $063C 32
COMMENT $063F 56
COMMENT $0642 15
COMMENT $0645 12
COMMENT $0648 12
COMMENT $064B 12
COMMENT $064E 15
COMMENT $0651 16
COMMENT_LINE $0654 phrases follow
COMMENT_LINE $0654 data follows
COMMENT $0690 flushed
COMMENT_LINE $0694 translation data
COMMENT_LINE $0694 DB $0A; bytes follow
COMMENT_LINE $0694 bits used, code, real 'byte'
COMMENT $0694 285
COMMENT $0697 12
COMMENT $069A 6
COMMENT $069D 15
COMMENT $06A0 15
COMMENT $06A3 3
COMMENT $06A6 3
COMMENT $06A9 3
COMMENT $06AC 3
COMMENT $06AF 3
COMMENT_LINE $06B2 phrases follow
COMMENT_LINE $06B2 data follows
COMMENT $06BC flushed
FORCE_SYMBOL $0720 BackGndCtr
FORCE_NO_SYMBOL $0723
FORCE_SYMBOL $0727 Clear_Sound
FORCE_NO_SYMBOL $072C
FORCE_SYMBOL $0730 do_ym_sound
FORCE_SYMBOL $0733 BackGndCtr
FORCE_NO_SYMBOL $0738
FORCE_SYMBOL $073A BackGndCtr
FORCE_SYMBOL $073D warp_start_2
FORCE_SYMBOL $0740 init_ym_sound
RANGE $0000-$0743 DP $D0
RANGE $0000-$000B CHAR_DATA 11
RANGE $000B-$000D DW_DATA 1
RANGE $000D-$0011 DB_DATA 4
RANGE $0011-$001D CHAR_DATA 12
RANGE $001D-$001E DB_DATA 1
RANGE $001E-$028E CODE
RANGE $028E-$0296 CHAR_DATA 8
RANGE $0296-$02A8 CHAR_DATA 18
RANGE $02A8-$02A9 DB_DATA 1
RANGE $02A9-$02AB DB_DATA 2
RANGE $02AB-$02AD DB_DATA 2
RANGE $02AD-$02AF DB_DATA 2
RANGE $02AF-$02B1 DB_DATA 2
RANGE $02B1-$02B3 DB_DATA 2
RANGE $02B3-$02B5 DB_DATA 2
RANGE $02B5-$02B7 DB_DATA 2
RANGE $02B7-$02B9 DB_DATA 2
RANGE $02B9-$0426 CODE
RANGE $0426-$0428 DW_DATA 1
RANGE $0428-$042B DB_DATA 3
RANGE $042B-$042E DB_DATA 3
RANGE $042E-$0431 DB_DATA 3
RANGE $0431-$0434 DB_DATA 3
RANGE $0434-$0437 DB_DATA 3
RANGE $0437-$043A DB_DATA 3
RANGE $043A-$043D DB_DATA 3
RANGE $043D-$0440 DB_DATA 3
RANGE $0440-$0443 DB_DATA 3
RANGE $0443-$0446 DB_DATA 3
RANGE $0446-$0449 DB_DATA 3
RANGE $0449-$044C DB_DATA 3
RANGE $044C-$044F DB_DATA 3
RANGE $044F-$0452 DB_DATA 3
RANGE $0452-$0455 DB_DATA 3
RANGE $0455-$0458 DB_DATA 3
RANGE $0458-$045B DB_DATA 3
RANGE $045B-$045E DB_DATA 3
RANGE $045E-$0461 DB_DATA 3
RANGE $0461-$0464 DB_DATA 3
RANGE $0464-$0467 DB_DATA 3
RANGE $0467-$0471 DB_DATA 10
RANGE $0471-$047B DB_DATA 10
RANGE $047B-$0484 DB_DATA 9
RANGE $0484-$0487 DB_DATA 3
RANGE $0487-$048A DB_DATA 3
RANGE $048A-$048D DB_DATA 3
RANGE $048D-$0490 DB_DATA 3
RANGE $0490-$0493 DB_DATA 3
RANGE $0493-$0496 DB_DATA 3
RANGE $0496-$0499 DB_DATA 3
RANGE $0499-$049C DB_DATA 3
RANGE $049C-$049F DB_DATA 3
RANGE $049F-$04A2 DB_DATA 3
RANGE $04A2-$04A5 DB_DATA 3
RANGE $04A5-$04A8 DB_DATA 3
RANGE $04A8-$04AB DB_DATA 3
RANGE $04AB-$04AE DB_DATA 3
RANGE $04AE-$04B1 DB_DATA 3
RANGE $04B1-$04B4 DB_DATA 3
RANGE $04B4-$04B7 DB_DATA 3
RANGE $04B7-$04BA DB_DATA 3
RANGE $04BA-$04BD DB_DATA 3
RANGE $04BD-$04C0 DB_DATA 3
RANGE $04C0-$04C3 DB_DATA 3
RANGE $04C3-$04C6 DB_DATA 3
RANGE $04C6-$04C9 DB_DATA 3
RANGE $04C9-$04CC DB_DATA 3
RANGE $04CC-$04CF DB_DATA 3
RANGE $04CF-$04D2 DB_DATA 3
RANGE $04D2-$04D5 DB_DATA 3
RANGE $04D5-$04D8 DB_DATA 3
RANGE $04D8-$04DB DB_DATA 3
RANGE $04DB-$04DE DB_DATA 3
RANGE $04DE-$04E1 DB_DATA 3
RANGE $04E1-$04E4 DB_DATA 3
RANGE $04E4-$04E7 DB_DATA 3
RANGE $04E7-$04EA DB_DATA 3
RANGE $04EA-$04F9 DB_DATA 15
RANGE $04F9-$0503 DB_DATA 10
RANGE $0503-$050D DB_DATA 10
RANGE $050D-$0517 DB_DATA 10
RANGE $0517-$0521 DB_DATA 10
RANGE $0521-$052B DB_DATA 10
RANGE $052B-$0535 DB_DATA 10
RANGE $0535-$053F DB_DATA 10
RANGE $053F-$0541 DB_DATA 2
RANGE $0541-$0544 DB_DATA 3
RANGE $0544-$0547 DB_DATA 3
RANGE $0547-$054A DB_DATA 3
RANGE $054A-$054D DB_DATA 3
RANGE $054D-$0550 DB_DATA 3
RANGE $0550-$0553 DB_DATA 3
RANGE $0553-$0556 DB_DATA 3
RANGE $0556-$0559 DB_DATA 3
RANGE $0559-$055C DB_DATA 3
RANGE $055C-$056B DB_DATA 15
RANGE $056B-$0575 DB_DATA 10
RANGE $0575-$057F DB_DATA 10
RANGE $057F-$0589 DB_DATA 10
RANGE $0589-$0593 DB_DATA 10
RANGE $0593-$0598 DB_DATA 5
RANGE $0598-$059B DB_DATA 3
RANGE $059B-$059E DB_DATA 3
RANGE $059E-$05A1 DB_DATA 3
RANGE $05A1-$05A4 DB_DATA 3
RANGE $05A4-$05A7 DB_DATA 3
RANGE $05A7-$05AA DB_DATA 3
RANGE $05AA-$05AD DB_DATA 3
RANGE $05AD-$05B0 DB_DATA 3
RANGE $05B0-$05B3 DB_DATA 3
RANGE $05B3-$05B6 DB_DATA 3
RANGE $05B6-$05B9 DB_DATA 3
RANGE $05B9-$05BC DB_DATA 3
RANGE $05BC-$05BF DB_DATA 3
RANGE $05BF-$05C2 DB_DATA 3
RANGE $05C2-$05C5 DB_DATA 3
RANGE $05C5-$05C8 DB_DATA 3
RANGE $05C8-$05CB DB_DATA 3
RANGE $05CB-$05CE DB_DATA 3
RANGE $05CE-$05D1 DB_DATA 3
RANGE $05D1-$05D4 DB_DATA 3
RANGE $05D4-$05D7 DB_DATA 3
RANGE $05D7-$05E1 DB_DATA 10
RANGE $05E1-$05EB DB_DATA 10
RANGE $05EB-$05F4 DB_DATA 9
RANGE $05F4-$05F7 DB_DATA 3
RANGE $05F7-$05FA DB_DATA 3
RANGE $05FA-$05FD DB_DATA 3
RANGE $05FD-$0600 DB_DATA 3
RANGE $0600-$0603 DB_DATA 3
RANGE $0603-$0606 DB_DATA 3
RANGE $0606-$060A DB_DATA 4
RANGE $060A-$060D DB_DATA 3
RANGE $060D-$0610 DB_DATA 3
RANGE $0610-$0613 DB_DATA 3
RANGE $0613-$0616 DB_DATA 3
RANGE $0616-$0619 DB_DATA 3
RANGE $0619-$061C DB_DATA 3
RANGE $061C-$061F DB_DATA 3
RANGE $061F-$0622 DB_DATA 3
RANGE $0622-$0625 DB_DATA 3
RANGE $0625-$0628 DB_DATA 3
RANGE $0628-$0632 DB_DATA 10
RANGE $0632-$0636 DB_DATA 4
RANGE $0636-$0639 DB_DATA 3
RANGE $0639-$063C DB_DATA 3
RANGE $063C-$063F DB_DATA 3
RANGE $063F-$0642 DB_DATA 3
RANGE $0642-$0645 DB_DATA 3
RANGE $0645-$0648 DB_DATA 3
RANGE $0648-$064B DB_DATA 3
RANGE $064B-$064E DB_DATA 3
RANGE $064E-$0651 DB_DATA 3
RANGE $0651-$0654 DB_DATA 3
RANGE $0654-$065E DB_DATA 10
RANGE $065E-$0668 DB_DATA 10
RANGE $0668-$0672 DB_DATA 10
RANGE $0672-$067C DB_DATA 10
RANGE $067C-$0686 DB_DATA 10
RANGE $0686-$0690 DB_DATA 10
RANGE $0690-$0694 DB_DATA 4
RANGE $0694-$0697 DB_DATA 3
RANGE $0697-$069A DB_DATA 3
RANGE $069A-$069D DB_DATA 3
RANGE $069D-$06A0 DB_DATA 3
RANGE $06A0-$06A3 DB_DATA 3
RANGE $06A3-$06A6 DB_DATA 3
RANGE $06A6-$06A9 DB_DATA 3
RANGE $06A9-$06AC DB_DATA 3
RANGE $06AC-$06AF DB_DATA 3
RANGE $06AF-$06B2 DB_DATA 3
RANGE $06B2-$06BC DB_DATA 10
RANGE $06BC-$06C0 DB_DATA 4
RANGE $06C0-$06C2 DW_DATA 1
RANGE $06C2-$06C3 DB_DATA 1
RANGE $06C3-$06C9 DW_DATA 3
RANGE $06C9-$06CA DB_DATA 1
RANGE $06CA-$06D0 DW_DATA 3
RANGE $06D0-$06D1 DB_DATA 1
RANGE $06D1-$06D7 DW_DATA 3
RANGE $06D7-$06D8 DB_DATA 1
RANGE $06D8-$06DE DW_DATA 3
RANGE $06DE-$06DF DB_DATA 1
RANGE $06DF-$06E5 DW_DATA 3
RANGE $06E5-$06E6 DB_DATA 1
RANGE $06E6-$06EC DW_DATA 3
RANGE $06EC-$06ED DB_DATA 1
RANGE $06ED-$06F3 DW_DATA 3
RANGE $06F3-$06F4 DB_DATA 1
RANGE $06F4-$06FA DW_DATA 3
RANGE $06FA-$06FB DB_DATA 1
RANGE $06FB-$0701 DW_DATA 3
RANGE $0701-$0702 DB_DATA 1
RANGE $0702-$0708 DW_DATA 3
RANGE $0708-$0709 DB_DATA 1
RANGE $0709-$070F DW_DATA 3
RANGE $070F-$0710 DB_DATA 1
RANGE $0710-$0720 DB_DATA 16
RANGE $0720-$0744 CODE

