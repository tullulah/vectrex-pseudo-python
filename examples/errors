[Compiler] Compiling project: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj
[Compiler] Using: /Users/daniel/projects/vectrex-pseudo-python/target/debug/vectrexc
Starting compilation: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj
[Compiler] Cleaned old output files
[Compiler] Full command: "/Users/daniel/projects/vectrex-pseudo-python/target/debug/vectrexc" build /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj --target vectrex --title TEST_CALLGRAPH --bin --include-dir /Users/daniel/projects/vectrex-pseudo-python --out /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/build/test_callgraph.asm
[Compiler] Working dir: /Users/daniel/projects/vectrex-pseudo-python
[Compiler] Mode: PROJECT (.vpyproj)
=== PROJECT COMPILATION START ===
Project file: 
/Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj
âœ“ Project: test_callgraph
âœ“ Entry file: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/src/main.vpy
âœ“ Output: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/build/test_callgraph.asm
=== COMPILATION PIPELINE START ===
Input file: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/src/main.vpy
Target: Vectrex
Binary generation: enabled
Assembler: native M6809 (integrated)
Phase 1: Reading source file...
âœ“ Phase 1 SUCCESS: Read 
1961 characters
Phase 2: Lexical analysis (tokenization)...
âœ“ Phase 2 SUCCESS: Generated 289 tokens
Phase 3: Syntax analysis (parsing)...
âœ“ Phase 3 SUCCESS: Parsed module with 16 top-level items
Phase 0: Asset discovery...
âœ“ Discovered 2 asset(s):
  - player (Vector)
  - enemy (Vector)
Phase 0.5: Analyzing .vplay files for dynamic buffer sizing...
âœ“ No physics objects found - buffer not needed
Phase 4: Code generation (ASM emission)...
[DEBUG] Found asset usage: player (DRAW_VECTOR)
[DEBUG] Found asset usage: enemy (DRAW_VECTOR)
[DEBUG] Found asset usage: enemy (DRAW_VECTOR)
[DEBUG] Found asset usage: enemy (DRAW_VECTOR)
[DEBUG] Used assets: 
{"enemy", "player"}
[DEBUG] Available assets: ["player", "enemy"]
[DEBUG] Assets to embed: 2
âœ“ Phase 4 SUCCESS: Generated 27540 bytes of assembly
   info 11:1 - Variable 'enemy1_y' never changes - consider 'const' to save RAM (2 bytes)
Phase 5: Writing assembly file...
âœ“ Phase 5 SUCCESS: Written to /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/build/test_callgraph.asm (target=vectrex)
Phase 5.5: Writing debug symbols file (.pdb)...
Phase 5.5: Debug symbols write deferred until after binary generation
Phase 6: Binary assembly requested...
=== BINARY ASSEMBLY PHASE ===
ASM input: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/build/test_callgraph.asm
BIN output: /Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/build/test_callgraph.bin
Using native M6809 assembler (integrated)...
Detected ORG address: 0x00
00
DEBUG evaluate_expression: expr='$C880+$00' left='$C880' right='$00'
DEBUG: offset parsed = 0x0000 (0)
DEBUG: base=0xC880 + offset=0x0000 = 0xC880
DEBUG evaluate_expression: expr='$C880+$02' left='$C880' right='$02'
DEBUG: offset parsed = 0x0002 (2)
DEBUG: base=0xC880 + offset=0x0002 = 0xC882
DEBUG evaluate_expression: expr='$C880+$04' left='$C880' right='$04'
DEBUG: offset parsed = 0x0004 (4)
DEBUG: base=0xC880 + offset=0x0004 = 0xC884
DEBUG evaluate_expression: expr='$C880+$06' left='$C880' right='$06'
DEBUG: offset parsed = 0x0006 (6)
DEBUG: base=0xC880 + offset=0x0006 = 0xC886
DEBUG evaluate_expression: expr='$C880+$08' left='$C880' right='$08'
DEBUG: offset parsed = 0x0008 (8)
DEBUG: base=0xC880 + offset=0x0008 = 0xC888
DEBUG evaluate_expression: expr='$C880+$0A' left='$C880' right='$0A'
DEBUG: offset parsed = 0x000A (10)
DEBUG: base=0xC880 + offset=0x000A = 0xC88A
DEBUG evaluate_expression: expr='$C880+$0C' left='$C880' right='$0C'
DEBUG: offset parsed = 0x000C (12)
DEBUG: base=0xC880 + offset=0x000C = 0xC88C
DEBUG evaluate_expression: expr='$C880+$0E' left='$C880' right='$0E'
DEBUG: offset parsed = 0x000E (14)
DEBUG: base=0xC880 + offset=0x000
E = 0xC88E
DEBUG evaluate_expression: expr='$C880+$10' left='$C880' right='$10'
DEBUG: offset parsed = 0x0010 (16)
DEBUG: base=0xC880 + offset=0x0010 = 0xC890
DEBUG evaluate_expression: expr='$C880+$11' left='$C880' right='$11'
DEBUG: offset parsed = 0x0011 (17)
DEBUG: base=0xC880 + offset=0x0011 = 0xC891
DEBUG evaluate_expression: expr='$C880+$12' left='$C880' right='$12'
DEBUG: offset parsed = 0x0012 (18)
DEBUG: base=0xC880 + offset=0x0012 = 0xC892
DEBUG evaluate_expression: expr='$C880+$14' left='$C880' right='$14'
DEBUG: offset parsed = 0x0014 (20)
DEBUG: base=0xC880 + offset=0x0014 = 0xC894
DEBUG evaluate_expression: expr='$C880+$15' left='$C880' right='$15'
DEBUG: offset parsed = 0x0015 (21)
DEBUG: base=0xC880 + offset=0x0015 = 0xC895
DEBUG evaluate_expression: expr='$C880+$16' left='$C880' right='$16'
DEBUG: offset parsed = 0x0016 (22)
DEBUG: base=0xC880 + offset=0x0016 = 0xC896
DEBUG evaluate_expression: expr='$C880+$17' left='$C880' right='$17'
DEBUG: offset parsed = 0x0017 (23)
DEBUG: base=0xC880 + offset=0x0017 = 0xC897
DEBUG evaluate_expression: expr='$C880+$18' left='$C880' right='$18'
DEBUG: offset parsed = 0x0018 (24)
DEBUG: base=0xC880 + offset=0x0018 = 0xC898
DEBUG evaluate_expression: expr='$C880+$19' left='$C880' right='$19'
DEBUG: offset parsed = 0x0019 (25)
DEBUG: base=0xC880 + offset=0x0019 = 0xC899
DEBUG evaluate_expression: expr='$C880+$1B' left='$C880' right='$1B'
DEBUG: offset parsed = 0x001B (27)
DEBUG: base=0xC880 + offset=0x001B = 0xC89B
DEBUG evaluate_expression: expr='$C880+$1D' left='$C880' right='$1D'
DEBUG: offset parsed = 0x001D (29)
DEBUG: base=0xC880 + offset=0x001D = 0xC89D
DEBUG evaluate_expression: expr='$C880+$1F' left='$C880' right='$1F'
DEBUG: offset parsed = 0x001F (31)
DEBUG: base=0xC880 + offset=0x001F = 0xC89F
DEBUG evaluate_expression: expr='$C880+$21' left='$C880' right='$21'
DEBUG: offset parsed = 0x0021 (33)
DEBUG: base=0xC880 + offset=0x0021 = 0xC8A1
DEBUG evaluate_expression: expr='$C880+$23' left='$C880' right='$23'
DEBUG: offset parsed = 0x0023 (35)
DEBUG: base=0xC880 + offset=0x0023 = 0xC8A3
DEBUG evaluate_expression: expr='$C880+$25' left='$C880' right='$25'
DEBUG: offset parsed = 0x0025 (37)
DEBUG: base=0xC880 + offset=0x0025 = 0xC8A5
DEBUG evaluate_expression: expr='$C880+$27' left='$C880' right='$27'
DEBUG: offset parsed = 0x0027 (39)
DEBUG: base=0xC880 + offset=0x0027 = 0xC8A7
DEBUG evaluate_expression: expr='$C880+$29' left='$C880' right='$29'
DEBUG: offset parsed = 0x0029 (41)
DEBUG: base=0xC880 + offset=0x0029 = 0xC8A9
DEBUG evaluate_expression: expr='$C880+$2B' left='$C880' right='$2B'
DEBUG: offset parsed = 0x002B (43)
DEBUG: base=0xC880 + offset=0x002B = 0xC8AB
DEBUG evaluate_expression: expr='$C880+$2D' left='$C880' right='$2D'
DEBUG: offset parsed = 0x002D (45)
DEBUG: base=0xC880 + offset=0x002D = 0xC8AD
DEBUG emit_word: word=0xC81B at offset=0x0031
DEBUG emit_word: word=0xC81C at offset=0x0046
DEBUG emit_word: word=0xC811 at offset=0x0050
DEBUG emit_word: word=0xC811 at offset=0x005F
DEBUG emit_word: word=0xC811 at offset=0x006E
DEBUG emit_word: word=0xC811 at offset=0x007D
ğŸ” parse_and_emit: TFR 'A,DP' (full line: 'TFR A,DP')
DEBUG emit_word: word=0xC8A8 at offset=0x0095
ğŸ” parse_and_emit: TFR 'B,A' (full line: 'TFR B,A')
ğŸ” parse_and_emit: LDA '2,S' (full line: 'LDA 2,S')
ğŸ› parse_indexed_mode: offset_str='2
' reg_str='S' reg_bits=0x60
ğŸ›   â†’ parsed offset: 2
ğŸ›   â†’ 5-bit postbyte: 0x62
ğŸ” parse_and_emit: LDA '2,S' (full line: 'LDA 2,S')
ğŸ› parse_indexed_mode: offset_str='2' reg_str='S' reg_bits=0x60
ğŸ›   â†’ parsed offset: 2
ğŸ›   â†’ 5-bit postbyte: 0x62
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
ğŸ” parse_and_emit: LDB ',X+
' (full line: 'LDB ,X+')
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
DEBUG emit_word: word=0xC88E at offset=0x00B7
DEBUG emit_word: word=0xC88E at offset=0x00D4
ğŸ” parse_and_emit: LEAX '2,X' (full line: 'LEAX 2,X')
ğŸ› parse_indexed_mode: offset_str='2' reg_str='X' reg_bits=0x00
ğŸ›   â†’ parsed offset: 2
ğŸ›   â†’ 5-bit postbyte: 0x0
2
ğŸ·ï¸  Line 210: Defined label 'DSL_LOOP' at addr=$00FE off=254
ğŸ” Line 211: [DSL_LOOP] LDA ,X+                 ; Read flag â†’ addr=$00FE off=254
ğŸ” parse_and_emit: LDA ',X+' (full line: '
LDA ,X+')
   âœ“ After: addr=$0100 off=256 (delta=0)
ğŸ” Line 212: [DSL_LOOP] CMPA #2                 ; Check end marker â†’ addr=$0100 off=256
   âœ“ After: addr=$0102 off=258 (delta=0)
ğŸ” Line 213: [DSL_LOOP] LBEQ DSL_DONE           ; Exit if end (long branch) â†’ addr=$0102 off=258
   âœ“ After: addr=$0106 off=262 (delta=0)
ğŸ” Line 214: [DSL_LOOP] CMPA #1                 ; Check next path marker â†’ addr=$0106 off=262
   âœ“ After: addr=$0108 off=264 (delta=0)
ğŸ” Line 215: [DSL_LOOP] LBEQ DSL_NEXT_PATH      ; Process next path (long branch) â†’ addr=$0108 off=264
   âœ“ After: addr=$010C off=268 (delta=0)
ğŸ” Line 217: [DSL_LOOP] CLR Vec_Misc_Count      ; Clear for relative line drawing (CRITICAL for continuity) â†’ addr=$010C off=268
DEBUG emit_word: word=0xC823 at offset=0x010D
   âœ“ After: addr=$010F off=271 (delta=0)
ğŸ” Line 218: [DSL_LOOP] LDB ,X+                 ; dy â†’ addr=$010F off=271
ğŸ” parse_and_emit: LDB ',X+' (full line: 'LDB ,X+')
   âœ“ After: addr=$0111 off=273 (delta=0)
ğŸ” Line 219: [DSL_LOOP] LDA ,X+                 ; dx â†’ addr=$0111
 off=273
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
   âœ“ After: addr=$0113 off=275 (delta=0)
ğŸ” Line 220: [DSL_LOOP] PSHS A                  ; Save dx â†’ addr=$0113 off=275
   âœ“ After: addr=$0115 off=277 (delta=0)
ğŸ” Line 221: [DSL_LOOP] STB VIA_port_a          ; dy to DAC â†’ addr=$0115 off=277
   âœ“ After: addr=$0118 off=280 (delta=0)
ğŸ” Line 222: [DSL_LOOP] CLR VIA_port_b â†’ addr=$0118 off=280
   âœ“ After: addr=$011B off=283 (delta=0)
ğŸ” Line 223: [
DSL_LOOP] LDA #1 â†’ addr=$011B off=283
   âœ“ After: addr=$011D off=285 (delta=0)
ğŸ” Line 224: [DSL_LOOP] STA VIA_port_b â†’ addr=$011D off=285
   âœ“ After: addr=$0120 off=288 (delta=0)
ğŸ” Line 225: [DSL_LOOP
] PULS A                  ; Restore dx â†’ addr=$0120 off=288
   âœ“ After: addr=$0122 off=290 (delta=0)
ğŸ” Line 226: [
DSL_LOOP] STA VIA_port_a          ; dx to DAC â†’ addr=$0122 off=290
   âœ“ After: addr=$0125 off=293 (delta=0)
ğŸ” Line 227: [DSL_LOOP] CLR VIA_t1_cnt_hi â†’ addr=$0125 off=293
   âœ“ After: addr=$0128 off=296 (delta=0)
ğŸ” Line 228: [DSL_LOOP] LDA #$FF â†’ addr=$0
128 off=296
   âœ“ After: addr=$012A off=298 (delta=0)
ğŸ” Line 229: [DSL_LOOP] STA VIA_shift_reg â†’ addr=$012A off=298
   âœ“ After: addr=$012D off=301 (delta=0)
ğŸ·ï¸  Line 238: Defined label 'DSL_NEXT_PATH' at addr=$013A off=314
ğŸ” Line 240: [DSL_NEXT_PATH] TFR X,D                 ; D = X (current position) â†’ addr=$013A off=314
ğŸ” parse_and_emit: TFR 'X,D' (full line: '
TFR X,D')
   âœ“ After: addr=$013C off=316 (delta=0)
ğŸ” Line 241: [DSL_NEXT_PATH] PSHS D                  ; Save X address â†’ addr=$013C off=316
   âœ“ After: addr=$013E off=318 (delta=0)
ğŸ” Line 242: [DSL_NEXT_PATH] LDA ,X+                 ; Read intensity (X now points to y_start) â†’ addr=$013E off=318
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
   âœ“ After: addr=$0140 off=320 (delta=0)
ğŸ” Line 243: [DSL_NEXT_PATH] PSHS A                  ; Save intensity â†’ addr=$0140 off=320
   âœ“ After: addr=$0142 off=322 (delta=0)
ğŸ” Line 244: [DSL_NEXT_PATH] LDB ,X+                 ; y_start â†’ addr=$0142 off=322
ğŸ” parse_and_emit: LDB ',X+' (full line: 'LDB ,X+')
   âœ“ After: addr=$0144 off=324 (delta=0)
ğŸ” Line 245: [DSL_NEXT_PATH] LDA ,X+                 ; x_start (X now points to next_y) â†’ addr=$0144 off=324
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
   âœ“ After: addr=$0146 off=326 (delta=0)
ğŸ” Line 
246: [DSL_NEXT_PATH] STD TEMP_YX             ; Save y,x â†’ addr=$0146 off=326
DEBUG emit_word: word=0xC88E at offset=0x0147
   âœ“ After: addr=$0149 off=329 (delta=0)
ğŸ” Line 247: [DSL_NEXT_PATH] PULS A                  ; Get intensity back â†’ addr=$0149 off=329
   âœ“ After: addr=$014B off=331 (delta=0)
ğŸ” Line 248
: [DSL_NEXT_PATH] PSHS A                  ; Save intensity again â†’ addr=$014B off=331
   âœ“ After: addr=$014D off=333 (delta=0)
ğŸ” Line 249: [DSL_NEXT_PATH] LDA #$D0 â†’ addr=$014D off=333
   âœ“ After: addr=$014F off=335 (delta=0)
ğŸ” Line 250: [DSL_NEXT_PATH] TFR A,DP                ; Set DP=$D0 (BIOS requirement) â†’ addr=$014F off=335
ğŸ” parse_and_emit: TFR
 'A,DP' (full line: 'TFR A,DP')
   âœ“ After: addr=$0151 off=337 (delta=0)
ğŸ” Line 251: [DSL_NEXT_PATH] PULS A                  ; Restore intensity â†’ addr=$0151 off=337
   âœ“ After: addr=$0153 off=339 (delta=0)
ğŸ” Line 252: [DSL_NEXT_PATH] JSR $F2AB               ; BIOS Intensity_a (may corrupt X!) â†’ addr=$0153 off=339
   âœ“ After: addr=$0156 off=342 (delta=0)
ğŸ” Line 254: [DSL_NEXT_PATH] PULS D                  ; Get original X â†’ addr=$0156 off=342
   âœ“ After: addr=$0158 off=344 (delta=0)
ğŸ” Line 255: [DSL_NEXT_PATH] ADDD #3                 ; Skip intensity, y_start, x_start â†’ addr=$0158 off=344
   âœ“ After: addr=$015B off=347 (delta=0)
ğŸ” Line 256: [DSL_NEXT_PATH] TFR D,X                 ; X now points to next_y â†’ addr=$015B off=347
ğŸ” parse_and_emit: TFR 'D,X' (full line: 'TFR D,X')
   âœ“ After: addr=$015D off=349 (delta=0)
ğŸ” Line 258: [DSL_NEXT_PATH] CLR VIA_shift_reg â†’ addr=$015D off=349
   âœ“ After: addr=$0160 off=352 (delta=0)
ğŸ” Line 259
: [DSL_NEXT_PATH] LDA #$CC â†’ addr=$0160 off=352
   âœ“ After: addr=$0162 off=354 (delta=0)
ğŸ” Line 260: [DSL_NEXT_PATH] STA VIA_cntl â†’ addr=$0162 off=354
   âœ“ After: addr=$0165 off=357 (delta=0)
ğŸ” Line 261: [DSL_NEXT_PATH] CLR VIA_port_a â†’ addr=$0165 off=357
   âœ“ After: addr=$0168 off=360 (delta=0)
ğŸ” Line 262: [DSL_NEXT_PATH] LDA #$82 â†’ addr=$0168 off=360
   âœ“ After: addr=$016A off=362 (delta=0)
ğŸ” Line 263: [DSL_NEXT_PATH] STA VIA_port_b â†’ addr=$
016A off=362
   âœ“ After: addr=$016D off=365 (delta=0)
ğŸ” Line 264: [DSL_NEXT_PATH] NOP â†’ addr=$016D off=365
   âœ“ After: addr=$016E off=366 (delta=0)
ğŸ” Line 265: [DSL_NEXT_PATH] NOP â†’ addr=$016E off=366
   âœ“ After: addr=$016F off=367 (delta=0)
ğŸ” Line 266: [DSL_NEXT_PATH] NOP â†’ addr=$016F off=367
   âœ“ After: addr=$0
170 off=368 (delta=0)
ğŸ” Line 267: [DSL_NEXT_PATH] NOP â†’ addr=$0170 off=368
   âœ“ After: addr=$0171 off=369 (delta=0)
ğŸ” Line 268: [DSL_NEXT_PATH] NOP â†’ addr=$0171 off=369
   âœ“ After: addr=$0172 off=370 (delta=0)
ğŸ” Line 269: [DSL_NEXT_PATH] LDA #$83 â†’ addr=$0172 off=370
   âœ“ After: addr=$0174 off=372 (delta=0)
ğŸ” Line 270: [DSL_NEXT_PATH] STA VIA_port_b â†’ addr=$0174
 off=372
   âœ“ After: addr=$0177 off=375 (delta=0)
ğŸ” Line 272: [DSL_NEXT_PATH] LDD TEMP_YX â†’ addr=$0177 off=375
DEBUG emit_word: word=0xC88E at offset=0x0178
   âœ“ After: addr=$017A off=378 (delta=0)
ğŸ” Line 273: [DSL_NEXT_PATH] STB VIA_port_a          ; y to DAC â†’ addr=$017A off=378
   âœ“ After: addr=$017D off=381 (delta=0)
ğŸ” Line 274: [DSL_NEXT_PATH] PSHS A â†’ addr=$017D off=381
   âœ“ After: addr=$017F off=383 (delta=0)
ğŸ” Line 275: [DSL_NEXT_PATH] LDA #$CE â†’ addr=$017F off=383
   âœ“ After: addr=$0181 off=385 (delta=0)
ğŸ” Line 276: [DSL_NEXT_PATH] STA VIA_cntl â†’ addr=$0181 off=
385
   âœ“ After: addr=$0184 off=388 (delta=0)
ğŸ” Line 277: [DSL_NEXT_PATH] CLR VIA_port_b â†’ addr=$0184 off=388
   âœ“ After: addr=$0187 off=391 (delta=0)
ğŸ” Line 278: [DSL_NEXT_PATH] LDA #1 â†’ addr=$0187 off=391
   âœ“ After: addr=$0189 off=393 (delta=0)
ğŸ” Line 279
: [DSL_NEXT_PATH] STA VIA_port_b â†’ addr=$0189 off=393
   âœ“ After: addr=$018C off=396 (delta=0)
ğŸ” Line 280: [DSL_NEXT_PATH] PULS A â†’ addr=$018C off=396
   âœ“ After: addr=$018E off=398 (delta=0)
ğŸ” Line 281: [DSL_NEXT_PATH] STA VIA_port_a          ; x to DAC â†’ addr=$018E off=398
   âœ“ After: addr=$0191 off=401 (delta=0)
ğŸ” Line 282: [DSL_NEXT_PATH] LDA #$7F â†’ addr=$0191 off=401
   âœ“ After: addr=$0193 off=403 (delta=0)
ğŸ” Line 283: [DSL_NEXT_PATH] STA VIA_t1_cnt_lo â†’ addr=$0193 off=403
   âœ“ After: addr=$0196 off=406 (delta=0)
ğŸ” Line 284: [DSL_NEXT_PATH] CLR VIA_t1_cnt_hi â†’ addr=$
0196 off=406
   âœ“ After: addr=$0199 off=409 (delta=0)
ğŸ” Line 285: [DSL_NEXT_PATH] LEAX 2,X                ; Skip next_y, next_x â†’ addr=$0199 off=409
ğŸ” parse_and_emit: LEAX '2,X' (full line: 'LEAX 2,X')
ğŸ› parse_indexed_mode: offset_str='2' reg_str='X' reg_bits=0x00
ğŸ›   â†’ parsed offset: 2
ğŸ›   â†’ 5-bit postbyte: 0x
02
   âœ“ After: addr=$019B off=411 (delta=0)
ğŸ·ï¸  Line 293: Defined label 'DSL_DONE' at addr=$01A8 off=424
ğŸ” Line 294: [DSL_DONE] RTS â†’ addr=$01A8 off=424
   âœ“ After: addr=$01A9 off=425 (delta=0)
DEBUG emit_word: word=0xC898 at offset=0x01AA
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
ğŸ” parse_and_emit: LEAX '1,X' (full line: 'LEAX 1,X')
ğŸ› parse_indexed_mode: offset_str='1' reg_str='X' reg_bits=0x00
ğŸ›   â†’ parsed offset: 1
ğŸ›   â†’ 5-bit postbyte: 0x01
ğŸ” parse_and_emit: LDB ',X+' (full line: 'LDB ,X+')
DEBUG emit_word: word=0xC895 at offset=0x01C0
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
DEBUG emit_word: word=0xC894 at offset=0x01CB
DEBUG emit_word: word=0xC88E at offset=0x01CE
DEBUG emit_word: word=0xC88E at offset=0x01EB
ğŸ” parse_and_emit: LEAX '2,X' (full line: 'LEAX 2,X')
ğŸ› parse_indexed_mode: offset_str='2' reg_str='X' reg_bits=0x00
ğŸ›   â†’ parsed offset: 2
ğŸ›   â†’ 5-bit postbyte: 0x02
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
ğŸ” parse_and_emit: LDB ',X+' (full line: 'LDB ,X+')
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
ğŸ” parse_and_emit: TFR 'X,D' (full line: 'TFR X,D')
DEBUG emit_word: word=0x
C898 at offset=0x025F
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
ğŸ” parse_and_emit: LEAX '1,X' (full line: 'LEAX 1,X
')
ğŸ› parse_indexed_mode: offset_str='1' reg_str='X' reg_bits=0x00
ğŸ›   â†’ parsed offset: 1
ğŸ›   â†’ 5-bit postbyte: 0x01
ğŸ” parse_and_emit: LDB ',X+' (full line: 'LDB ,X+')
DEBUG emit_word: word=0xC895 at offset=0x0274
ğŸ” parse_and_emit: LDA ',X+' (full line: 'LDA ,X+')
DEBUG emit_word: word=0xC894 at offset=0x027F
DEBUG emit_word: word=0xC88E at offset=0x0282
ğŸ” parse_and_emit: TFR 'D,X' (full line: 'TFR D,X')
DEBUG emit_word: word=0xC88E at offset=0x02AB
ğŸ” parse_and_emit: LEAX '2,X' (full line: 'LEAX 2,X')
ğŸ› parse_indexed_mode: offset_str='2' reg_str='X' reg_bits=0x0
0
ğŸ›   â†’ parsed offset: 2
ğŸ›   â†’ 5-bit postbyte: 0x02
ğŸ·ï¸  Defining label 'START' at current_address=0x02DC (offset=0x02DC)
ğŸ” parse_and_emit: TFR 'A,DP' (full line: 'TFR A,DP')
DEBUG emit_word: word=0xC80E at offset=0x02E1
âŒ Native assembler failed: Error en lÃ­nea 476: InstrucciÃ³n no soportada: LDS (cÃ³digo: 'LDS #$CBFF       ; Initialize stack at top of RAM (safer than Vec_Default_Stk)')
Please fix the assembly errors above.
Alternative: Use --use-lwasm flag to try external lwasm assembler
             (WARNING: No debug symbols with lwasm)
âŒ PHASE 6 FAILED: Binary assembly error
   Error: Native assembler failed: Error en lÃ­nea 476: InstrucciÃ³n no soportada: LDS (cÃ³digo: 'LDS #$CBFF       ; Initialize stack at top of RAM (safer than Vec_Default_Stk)')
Error: Native assembler failed: Error en lÃ­nea 476: InstrucciÃ³n no soportada: LDS (cÃ³digo: 'LDS #$CBFF       ; Initialize stack at top of RAM (safer than Vec_Default_Stk)')
Compilation FAILED (exit 1)
/Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj:1:1: âŒ Native assembler failed: Error en lÃ­nea 476: InstrucciÃ³n no soportada: LDS (cÃ³digo: 'LDS #$CBFF       ; Initialize stack at top of RAM (safer than Vec_Default_Stk)')
/Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj:1:1: Please fix the assembly errors above.
/Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj:1:1: âŒ PHASE 6 FAILED: Binary assembly error
/Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj:1:1: Error: Native assembler failed: Error en lÃ­nea 476: InstrucciÃ³n no soportada: LDS (cÃ³digo: 'LDS #$CBFF       ; Initialize stack at top of RAM (safer than Vec_Default_Stk)')
/Users/daniel/projects/vectrex-pseudo-python/examples/test_callgraph/test_callgraph.vpyproj:1:1: Error: Native assembler failed: Error en lÃ­nea 476: InstrucciÃ³n no soportada: LDS (cÃ³digo: 'LDS #$CBFF       ; Initialize stack at top of RAM (safer than Vec_Default_Stk)')