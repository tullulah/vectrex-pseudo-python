use vectrex_emulator::cpu6809::CPU;
use std::fs;
use std::io::Write;

#[derive(Debug, Clone)]
struct EmulatorState {
    pc: u16,
    opcode: u8,
    a: u8,
    b: u8,
    x: u16,
    y: u16,
    s: u16,
    u: u16,
    dp: u8,
    cc: u8,
}

impl EmulatorState {
    fn from_rust_cpu(cpu: &CPU) -> Self {
        Self {
            pc: cpu.pc,
            opcode: cpu.bus.mem[cpu.pc as usize],
            a: cpu.a,
            b: cpu.b,
            x: cpu.x,
            y: cpu.y,
            s: cpu.s,
            u: cpu.u,
            dp: cpu.dp,
            cc: (if cpu.cc_e { 0x80 } else { 0 }) |
                (if cpu.cc_f { 0x40 } else { 0 }) |
                (if cpu.cc_h { 0x20 } else { 0 }) |
                (if cpu.cc_i { 0x10 } else { 0 }) |
                (if cpu.cc_n { 0x08 } else { 0 }) |
                (if cpu.cc_z { 0x04 } else { 0 }) |
                (if cpu.cc_v { 0x02 } else { 0 }) |
                (if cpu.cc_c { 0x01 } else { 0 }),
        }
    }
}

fn capture_rust_emulator_states(steps: usize) -> Vec<EmulatorState> {
    // Cargar BIOS real
    let bios_path = r"C:\Users\DanielFerrerGuerrero\source\repos\pseudo-python\ide\frontend\dist\bios.bin";
    let bios_data = fs::read(bios_path).expect("Failed to load BIOS");
    
    // Crear CPU
    let mut cpu = CPU::default();
    
    // Cargar BIOS usando el mÃ©todo oficial
    cpu.load_bios(&bios_data);
    
    // Reset del CPU
    cpu.reset();
    
    let mut states = Vec::new();
    
    for _step in 0..steps {
        // Capturar estado antes del step
        states.push(EmulatorState::from_rust_cpu(&cpu));
        
        // Ejecutar un paso
        let old_pc = cpu.pc;
        cpu.step();
        
        // Detectar bucles infinitos simples
        if states.len() > 2 && cpu.pc == old_pc {
            println!("âš  PC unchanged at step {}, possible infinite loop", _step);
            break;
        }
        
        // Verificar si se estÃ¡ ejecutando fuera del rango esperado
        if cpu.pc < 0xE000 && cpu.pc > 0x1000 {
            println!("âš  PC outside expected range: 0x{:04X} at step {}", cpu.pc, _step);
        }
    }
    
    states
}

fn compare_emulators(steps: usize) {
    println!("\n=== COMPARACIÃ“N DE EMULADORES ({} pasos) ===", steps);
    
    // Capturar estados del emulador Rust
    let rust_states = capture_rust_emulator_states(steps);
    
    // Crear archivo de salida
    let output_dir = r"C:\Users\DanielFerrerGuerrero\source\repos\pseudo-python";
    let filename = format!("emulator_comparison_{}_steps.txt", steps);
    let filepath = format!("{}\\{}", output_dir, filename);
    
    let mut file = std::fs::File::create(&filepath).expect("Failed to create output file");
    
    // Escribir header al archivo
    writeln!(file, "=== COMPARACIÃ“N DE EMULADORES ({} pasos) ===", steps).unwrap();
    writeln!(file, "Generated by Rust emulator test").unwrap();
    writeln!(file, "BIOS Path: C:\\Users\\DanielFerrerGuerrero\\source\\repos\\pseudo-python\\ide\\frontend\\dist\\bios.bin").unwrap();
    writeln!(file, "").unwrap();
    
    // Escribir tabla al archivo
    writeln!(file, "â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”").unwrap();
    writeln!(file, "â”‚ Step â”‚  PC  â”‚ Opcode â”‚ A  â”‚ B  â”‚  X   â”‚  Y   â”‚  S   â”‚  U   â”‚ DP â”‚ CC â”‚").unwrap();
    writeln!(file, "â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤").unwrap();
    
    for (i, state) in rust_states.iter().enumerate() {
        let line = format!(
            "â”‚ {:4} â”‚ {:04X} â”‚   0x{:02X}   â”‚ {:02X} â”‚ {:02X} â”‚ {:04X} â”‚ {:04X} â”‚ {:04X} â”‚ {:04X} â”‚ {:02X} â”‚ {:02X} â”‚",
            i,
            state.pc,
            state.opcode,
            state.a,
            state.b,
            state.x,
            state.y,
            state.s,
            state.u,
            state.dp,
            state.cc
        );
        writeln!(file, "{}", line).unwrap();
        
        // TambiÃ©n mostrar en consola (pero limitado para evitar spam)
        if i < 50 || i >= rust_states.len() - 10 {
            println!("{}", line);
        } else if i == 50 {
            println!("â”‚ ...  â”‚ ...  â”‚  ...   â”‚ .. â”‚ .. â”‚ .... â”‚ .... â”‚ .... â”‚ .... â”‚ .. â”‚ .. â”‚");
        }
    }
    
    writeln!(file, "â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜").unwrap();
    writeln!(file, "Estados capturados: {}", rust_states.len()).unwrap();
    
    // Escribir anÃ¡lisis al archivo
    writeln!(file, "").unwrap();
    writeln!(file, "=== ANÃLISIS ===").unwrap();
    
    // Detectar bucles
    if rust_states.len() > 100 {
        let last_states = &rust_states[rust_states.len().saturating_sub(50)..];
        let mut loop_patterns = std::collections::HashMap::new();
        
        for state in last_states {
            let key = (state.pc, state.opcode);
            *loop_patterns.entry(key).or_insert(0) += 1;
        }
        
        writeln!(file, "Patrones frecuentes en los Ãºltimos 50 estados:").unwrap();
        let mut patterns: Vec<_> = loop_patterns.iter().collect();
        patterns.sort_by(|a, b| b.1.cmp(a.1));
        
        for ((pc, opcode), count) in patterns.iter().take(5) {
            writeln!(file, "  PC={:04X} Opcode=0x{:02X} â†’ {} veces", pc, opcode, count).unwrap();
        }
    }
    
    // EstadÃ­sticas de PC
    let unique_pcs: std::collections::HashSet<_> = rust_states.iter().map(|s| s.pc).collect();
    writeln!(file, "Direcciones PC Ãºnicas visitadas: {}", unique_pcs.len()).unwrap();
    
    let bios_instructions = rust_states.iter().filter(|s| s.pc >= 0xE000).count();
    writeln!(file, "Instrucciones ejecutadas en BIOS (>= 0xE000): {}", bios_instructions).unwrap();
    
    println!("â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜");
    println!("Estados capturados: {}", rust_states.len());
    println!("ğŸ“„ Resultados guardados en: {}", filepath);
}

#[test]
fn test_emulator_comparison_100() {
    compare_emulators(100);
}

#[test]
fn test_emulator_comparison_200() {
    compare_emulators(200);
}

#[test]
fn test_emulator_comparison_500() {
    compare_emulators(500);
}

#[test]
fn test_emulator_comparison_1000() {
    compare_emulators(1000);
}

#[test]
fn test_emulator_comparison_2000() {
    compare_emulators(2000);
}

#[test]
fn test_emulator_comparison_5000() {
    compare_emulators(5000);
}