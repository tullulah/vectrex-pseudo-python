use std::fs;
use vectrex_emulator::emulator::Emulator;

fn main() {
    println!("=== COMPARACI√ìN SUPER EXTENDIDA DE EMULADORES (100,000 pasos) ===");
    println!("Generated by Rust emulator test (SUPER EXTENDED VERSION)");
    
    let bios_path = r"C:\Users\DanielFerrerGuerrero\source\repos\pseudo-python\ide\frontend\dist\bios.bin";
    println!("BIOS Path: {}", bios_path);
    
    // Inicializar emulador
    let mut emulator = Emulator::new();
    
    // Cargar BIOS
    match fs::read(bios_path) {
        Ok(bios_data) => {
            emulator.load_bios(&bios_data);
            println!("‚úÖ BIOS cargada correctamente");
        }
        Err(e) => {
            eprintln!("‚ùå Error cargando BIOS: {}", e);
            return;
        }
    }
    
    // Cargar un cartucho simple
    let cart_data = vec![
        0x16, 0xF0, 0x00,  // Reset vector apunta a 0xF000
        0x00, 0x00,        // Padding
    ];
    emulator.load_cartridge(&cart_data);
    
    emulator.reset();
    
    let mut output_lines = Vec::new();
    let clr_indexed_count = 0; // No lo detectamos en esta versi√≥n simplificada
    let mut x_changes = 0;
    let mut prev_debug = emulator.debug_state();
    let mut vector_count = 0;
    let mut bios_frame_count = 0;
    
    let max_steps = 100_000;
    
    for step in 0..max_steps {
        let prev_debug_state = emulator.debug_state();
        
        // Ejecutar un paso
        let step_result = emulator.step();
        if !step_result {
            println!("‚ö†Ô∏è  CPU halted at step {}", step);
            break;
        }
        
        let current_debug = emulator.debug_state();
        
        // Detectar cambios en X
        if current_debug.cpu_x != prev_debug_state.cpu_x {
            x_changes += 1;
            if step < 50 {  // Solo mostrar los primeros para debug
                let line = format!("  -> X register changed: {:04X} -> {:04X}", 
                    prev_debug_state.cpu_x, current_debug.cpu_x);
                output_lines.push(line);
            }
        }
        
        // Por simplicidad, no detectamos CLR indexed espec√≠ficamente en esta version
        // Solo contamos cambios generales en X para ver patrones
        
        // Buscar vectores y frames BIOS (verificar cada 1000 pasos para eficiencia)
        if step % 1000 == 0 {
            // Verificar si hay vectores disponibles
            let vectors = emulator.drain_vector_segments();
            if !vectors.is_empty() {
                vector_count += vectors.len();
                
                // Mostrar algunos vectores como ejemplo
                if vector_count <= 50 {  // Limitar salida
                    for vector in vectors.iter().take(3) {
                        let line = format!("üìê Vector: start=({:.1},{:.1}), end=({:.1},{:.1}), intensity={}", 
                            vector.x0, vector.y0, vector.x1, vector.y1, vector.intensity);
                        output_lines.push(line);
                    }
                }
            }
            
            // Verificar frames BIOS
            if current_debug.bios_frame > prev_debug.bios_frame {
                bios_frame_count += 1;
                if bios_frame_count <= 10 {  // Limitar salida
                    let line = format!("BIOS Frame completed #{} at step {} (frame #{})", 
                        bios_frame_count, step, current_debug.bios_frame);
                    output_lines.push(line);
                }
                prev_debug.bios_frame = current_debug.bios_frame;
            }
        }
        
        // Solo loggear pasos espec√≠ficos para reducir el tama√±o del archivo
        if step < 100 || step % 10000 == 0 {
            let step_line = format!("Step {}: PC={:04X} -> PC={:04X} X={:04X} Y={:04X} A={:02X} B={:02X} cycles={}",
                step, prev_debug_state.cpu_pc, current_debug.cpu_pc, 
                current_debug.cpu_x, current_debug.cpu_y, current_debug.cpu_a, current_debug.cpu_b,
                current_debug.total_cycles);
            output_lines.push(step_line);
        }
        
        // Progress update cada 10000 pasos
        if step % 10000 == 0 {
            println!("Progreso: {} / {} pasos ({:.1}%) - X: {:04X}, Frames: {}, Vectores: {}", 
                step, max_steps, (step as f32 / max_steps as f32) * 100.0,
                current_debug.cpu_x, current_debug.bios_frame, vector_count);
        }
    }
    
    let final_debug = emulator.debug_state();
    
    // Estad√≠sticas finales
    output_lines.push("".to_string());
    output_lines.push("=== ESTAD√çSTICAS FINALES ===".to_string());
    output_lines.push(format!("Total operaciones CLR indexed: {}", clr_indexed_count));
    output_lines.push(format!("Total cambios en registro X: {}", x_changes));
    output_lines.push(format!("Total vectores generados: {}", vector_count));
    output_lines.push(format!("Total frames BIOS completados: {}", final_debug.bios_frame));
    output_lines.push(format!("Estado final X: {:04X}", final_debug.cpu_x));
    output_lines.push(format!("Estado final PC: {:04X}", final_debug.cpu_pc));
    
    // Escribir archivo
    let output_filename = "../emulator_comparison_100000_steps.txt";
    let output_content = output_lines.join("\n");
    
    match fs::write(output_filename, output_content) {
        Ok(_) => println!("‚úÖ Archivo generado: {}", output_filename),
        Err(e) => eprintln!("‚ùå Error escribiendo archivo: {}", e),
    }
    
    // Resumen en consola
    println!("\n=== RESUMEN FINAL ===");
    println!("‚úÖ Pasos ejecutados: {}", max_steps);
    println!("üìä Operaciones CLR indexed: {}", clr_indexed_count);
    println!("üîÑ Cambios en registro X: {}", x_changes);
    println!("üìê Vectores generados: {}", vector_count);
    println!("üé¨ Frames BIOS completados: {}", final_debug.bios_frame);
    
    if clr_indexed_count > 0 {
        let efficiency = (clr_indexed_count - x_changes) as f32 / clr_indexed_count as f32 * 100.0;
        println!("‚ö° Eficiencia fix CLR indexed: {:.1}% ({}% de operaciones NO modifican X)", 
            efficiency, (efficiency as u32));
    }
    
    if vector_count > 0 && final_debug.bios_frame > 0 {
        println!("‚úÖ El emulador backend est√° funcionando correctamente");
        println!("üìã Si la UI muestra problemas, es un issue de frontend/comunicaci√≥n");
    } else {
        println!("‚ö†Ô∏è  Pocos o ning√∫n vector/frame generado - necesita m√°s pasos o hay problemas");
    }
}