use vectrex_emulator::cpu6809::CPU;
use std::fs;

fn main() {
    println!("=== GENERANDO COMPARACIÓN EXTENDIDA (10,000 pasos) ===");
    
    let bios_path = r"C:\\Users\\DanielFerrerGuerrero\\source\\repos\\pseudo-python\\ide\\frontend\\dist\\bios.bin";
    let bios = fs::read(bios_path).expect("no se pudo leer bios.bin");
    
    println!("Generando comparación de 10,000 pasos...");
    
    let mut cpu = CPU::default();
    cpu.load_bios(&bios);
    cpu.reset();
    
    let filename = "../emulator_comparison_10000_steps.txt";
    let mut output = String::new();
    
    output.push_str("=== COMPARACIÓN EXTENDIDA DE EMULADORES (10,000 pasos) ===\n");
    output.push_str("Generated by Rust emulator test (EXTENDED VERSION)\n");
    output.push_str(&format!("BIOS Path: {}\n\n", bios_path));
    
    let mut clr_indexed_count = 0;
    let mut x_changes = 0;
    
    for step in 0..10000 {
        let pc_before = cpu.pc;
        let x_before = cpu.x;
        let a = cpu.a;
        let b = cpu.b;
        let y = cpu.y;
        let s = cpu.s;
        let u = cpu.u;
        let dp = cpu.dp;
        
        let opcode = cpu.bus.mem[cpu.pc as usize];
        let postbyte = if cpu.pc < 0xFFFF { cpu.bus.mem[(cpu.pc + 1) as usize] } else { 0 };
        
        // Pack CC flags manually
        let cc = (if cpu.cc_e { 0x80 } else { 0 }) |
                 (if cpu.cc_f { 0x40 } else { 0 }) |
                 (if cpu.cc_h { 0x20 } else { 0 }) |
                 (if cpu.cc_i { 0x10 } else { 0 }) |
                 (if cpu.cc_n { 0x08 } else { 0 }) |
                 (if cpu.cc_z { 0x04 } else { 0 }) |
                 (if cpu.cc_v { 0x02 } else { 0 }) |
                 (if cpu.cc_c { 0x01 } else { 0 });
        
        // Ejecutar un paso
        let success = cpu.step();
        if !success {
            output.push_str(&format!("CPU HALTED at step {}\n", step));
            break;
        }
        
        let pc_after = cpu.pc;
        let x_after = cpu.x;
        
        // Formato de línea compatible con JSVecx
        output.push_str(&format!(
            "Step {}: PC={:04X} executed: Opcode_{:02X} | PC={:04X} X={:04X} Y={:04X} U={:04X} S={:04X} A={:02X} B={:02X} DP={:02X} CC={:02X} cycles={}\n",
            step, pc_before, opcode, pc_after, x_after, y, u, s, a, b, dp, cc, cpu.cycles
        ));
        
        // Detectar CLR indexed específicamente
        if opcode == 0x6F {
            clr_indexed_count += 1;
            output.push_str(&format!(
                "  -> CLR indexed (0x6F) detected: postbyte={:02X}, X {:04X} -> {:04X}\n",
                postbyte, x_before, x_after
            ));
        }
        
        // Contar cambios en X
        if x_before != x_after {
            x_changes += 1;
            if step < 50 || clr_indexed_count > 0 {  // Log primeros cambios o cambios con CLR
                output.push_str(&format!("  -> X register changed: {:04X} -> {:04X}\n", x_before, x_after));
            }
        }
        
        // Progress cada 1000 pasos
        if step % 1000 == 0 {
            println!("Generado paso {}/10000", step);
        }
    }
    
    // Estadísticas finales
    output.push_str(&format!("\n=== ESTADÍSTICAS FINALES ===\n"));
    output.push_str(&format!("Total operaciones CLR indexed: {}\n", clr_indexed_count));
    output.push_str(&format!("Total cambios en registro X: {}\n", x_changes));
    output.push_str(&format!("Estado final X: {:04X}\n", cpu.x));
    
    // Escribir archivo
    if let Err(e) = fs::write(filename, output) {
        println!("Error escribiendo {}: {}", filename, e);
    } else {
        println!("✅ Archivo generado: {}", filename);
        println!("Operaciones CLR indexed detectadas: {}", clr_indexed_count);
        println!("Cambios en registro X: {}", x_changes);
    }
}