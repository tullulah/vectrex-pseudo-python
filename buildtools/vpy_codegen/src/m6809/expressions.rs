//! Expression Compilation for M6809
//!
//! Compiles VPy expressions to M6809 assembly
//! Result stored in RESULT (2-byte RAM variable)

use vpy_parser::{Expr, BinOp, CmpOp, LogicOp};
use super::builtins;
use super::context;  // For checking mutable arrays
use crate::AssetInfo;
use std::sync::atomic::{AtomicUsize, Ordering};

static LABEL_COUNTER: AtomicUsize = AtomicUsize::new(0);

/// Emit code for simple expression (numbers, vars, strings, calls)
pub fn emit_simple_expr(expr: &Expr, out: &mut String, assets: &[AssetInfo]) {
    match expr {
        Expr::Number(n) => {
            out.push_str(&format!("    LDD #{}\n", n));
            out.push_str("    STD RESULT\n");
        }
        
        Expr::StringLit(s) => {
            // String literals use hash-based labels generated by builtins::collect_print_text_strings
            let label = format!("PRINT_TEXT_STR_{}", builtins::hash_string(s));
            out.push_str(&format!("    LDX #{}      ; Pointer to string literal \"{}\"\n", label, s));
            out.push_str("    STX RESULT\n");
        }
        
        Expr::Ident(id) => {
            // Variable references use uppercase labels
            out.push_str(&format!("    LDD VAR_{}\n", id.name.to_uppercase()));
            out.push_str("    STD RESULT\n");
        }
        
        Expr::Call(call) => {
            // Check if builtin
            if builtins::emit_builtin(&call.name, &call.args, out, assets) {
                return;
            }
            
            // User function call (name already uppercase from unifier)
            // Evaluate arguments and store in VAR_ARG0-4
            for (i, arg) in call.args.iter().enumerate().take(5) {
                emit_simple_expr(arg, out, assets);
                out.push_str("    LDD RESULT\n");
                out.push_str(&format!("    STD VAR_ARG{}\n", i));
            }
            
            // Call function
            out.push_str(&format!("    JSR {}\n", call.name));
        }
        
        Expr::Binary { left, op, right } => {
            emit_binop(left, *op, right, out, assets);
        }

        Expr::Logic { op, left, right } => {
            let id = LABEL_COUNTER.fetch_add(1, Ordering::SeqCst);
            match op {
                LogicOp::And => {
                    // Short-circuit AND: if left is false, result is 0 (false)
                    emit_simple_expr(left, out, assets);
                    out.push_str("    LDD RESULT\n");
                    out.push_str(&format!("    LBEQ .LOGIC_{}_FALSE\n", id));
                    
                    // Left is true, check right
                    emit_simple_expr(right, out, assets);
                    out.push_str("    LDD RESULT\n");
                    out.push_str(&format!("    LBEQ .LOGIC_{}_FALSE\n", id));
                    
                    // Both true
                    out.push_str("    LDD #1\n");
                    out.push_str(&format!("    LBRA .LOGIC_{}_END\n", id));
                    
                    out.push_str(&format!(".LOGIC_{}_FALSE:\n", id));
                    out.push_str("    LDD #0\n");
                    out.push_str(&format!(".LOGIC_{}_END:\n", id));
                    out.push_str("    STD RESULT\n");
                }
                LogicOp::Or => {
                    // Short-circuit OR: if left is true, result is 1 (true)
                    emit_simple_expr(left, out, assets);
                    out.push_str("    LDD RESULT\n");
                    out.push_str(&format!("    LBNE .LOGIC_{}_TRUE\n", id));
                    
                    // Left is false, check right
                    emit_simple_expr(right, out, assets);
                    out.push_str("    LDD RESULT\n");
                    out.push_str(&format!("    LBNE .LOGIC_{}_TRUE\n", id));
                    
                    // Both false
                    out.push_str("    LDD #0\n");
                    out.push_str(&format!("    LBRA .LOGIC_{}_END\n", id));
                    
                    out.push_str(&format!(".LOGIC_{}_TRUE:\n", id));
                    out.push_str("    LDD #1\n");
                    out.push_str(&format!(".LOGIC_{}_END:\n", id));
                    out.push_str("    STD RESULT\n");
                }
            }
        }
        
        Expr::Not(expr) => {
            let id = LABEL_COUNTER.fetch_add(1, Ordering::SeqCst);
            emit_simple_expr(expr, out, assets);
            out.push_str("    LDD RESULT\n");
            out.push_str(&format!("    LBNE .NOT_{}_ZERO\n", id));
            out.push_str("    LDD #1\n");
            out.push_str(&format!("    LBRA .NOT_{}_END\n", id));
            out.push_str(&format!(".NOT_{}_ZERO:\n", id));
            out.push_str("    LDD #0\n");
            out.push_str(&format!(".NOT_{}_END:\n", id));
            out.push_str("    STD RESULT\n");
        }
        
        Expr::BitNot(expr) => {
            emit_simple_expr(expr, out, assets);
            out.push_str("    LDD RESULT\n");
            out.push_str("    COMA\n");
            out.push_str("    COMB\n");
            out.push_str("    STD RESULT\n");
        }
        
        Expr::Compare { left, op, right } => {
            emit_compare(left, *op, right, out, assets);
        }
        
        Expr::Index { target, index } => {
            emit_index(target, index, out, assets);
        }
        
        _ => {
            // Unimplemented expression types (List, StructInit, FieldAccess, MethodCall)
            // These should likely be transformed before codegen or are not supported yet
            out.push_str(&format!("    ; Unimplemented Expr {:?}\n", expr));
            out.push_str("    LDD #0\n");
            out.push_str("    STD RESULT\n");
        }
    }
}

fn emit_binop(left: &Expr, op: BinOp, right: &Expr, out: &mut String, assets: &[AssetInfo]) {
    // Evaluate left
    emit_simple_expr(left, out, assets);
    out.push_str("    LDD RESULT\n");
    out.push_str("    PSHS D\n");
    
    // Evaluate right
    emit_simple_expr(right, out, assets);
    out.push_str("    LDD RESULT\n");
    
    // Perform operation
    match op {
        BinOp::Add => {
            out.push_str("    ADDD ,S++\n");
        }
        BinOp::Sub => {
            out.push_str("    STD TMPPTR      ; Save right operand\n");
            out.push_str("    PULS D          ; Get left operand\n");
            out.push_str("    SUBD TMPPTR     ; Left - Right\n");
        }
        BinOp::Mul => {
            out.push_str("    PULS X      ; Get left into X\n");
            out.push_str("    JSR MUL16   ; D = X * D\n");
        }
        BinOp::Div | BinOp::FloorDiv => {
            out.push_str("    PULS X      ; Get left into X\n");
            out.push_str("    JSR DIV16   ; D = X / D\n");
        }
        BinOp::Mod => {
            out.push_str("    PULS X      ; Get left into X\n");
            out.push_str("    JSR MOD16   ; D = X % D\n");
        }
        BinOp::Shl => {
            // Shift Left: D = Left << Right
            let id = LABEL_COUNTER.fetch_add(1, Ordering::SeqCst);
            out.push_str("    STD TMPPTR      ; Save shift amount (Right)\n");
            out.push_str("    PULS D          ; Get value to shift (Left)\n");
            out.push_str("    LDX TMPPTR      ; Load shift amount into X\n");
            out.push_str(&format!("    BEQ .SHL_{}_END\n", id)); // Shift 0 -> done
            
            // Limit shift to 16
            out.push_str("    CMPX #16\n");
            out.push_str(&format!("    BLE .SHL_{}_LOOP\n", id));
            out.push_str("    LDX #16\n");
            
            out.push_str(&format!(".SHL_{}_LOOP:\n", id));
            out.push_str("    ASLB\n");
            out.push_str("    ROLA\n");
            out.push_str("    LEAX -1,X\n");
            out.push_str(&format!("    BNE .SHL_{}_LOOP\n", id));
            
            out.push_str(&format!(".SHL_{}_END:\n", id));
        }
        BinOp::Shr => {
            // Shift Right: D = Left >> Right
            let id = LABEL_COUNTER.fetch_add(1, Ordering::SeqCst);
            out.push_str("    STD TMPPTR      ; Save shift amount\n");
            out.push_str("    PULS D          ; Get value\n");
            out.push_str("    LDX TMPPTR\n");
            out.push_str(&format!("    BEQ .SHR_{}_END\n", id));
            
            out.push_str("    CMPX #16\n");
            out.push_str(&format!("    BLE .SHR_{}_LOOP\n", id));
            out.push_str("    LDX #16\n");
            
            out.push_str(&format!(".SHR_{}_LOOP:\n", id));
            out.push_str("    ASRA\n");
            out.push_str("    RORB\n");
            out.push_str("    LEAX -1,X\n");
            out.push_str(&format!("    BNE .SHR_{}_LOOP\n", id));
            
            out.push_str(&format!(".SHR_{}_END:\n", id));
        }
        BinOp::BitAnd => {
            out.push_str("    PULS X\n");
            out.push_str("    ANDA X\n");
            out.push_str("    ANDB X+1\n");
        }
        BinOp::BitOr => {
            out.push_str("    PULS X\n");
            out.push_str("    ORA X\n");
            out.push_str("    ORB X+1\n");
        }
        BinOp::BitXor => {
            out.push_str("    PULS X\n");
            out.push_str("    EORA X\n");
            out.push_str("    EORB X+1\n");
        }
    }
    
    out.push_str("    STD RESULT\n");
}

fn emit_compare(left: &Expr, op: CmpOp, right: &Expr, out: &mut String, assets: &[AssetInfo]) {
    let id = LABEL_COUNTER.fetch_add(1, Ordering::SeqCst);
    
    // CRITICAL FIX: Evaluate RIGHT first, push to stack
    // Then evaluate LEFT, compare D (LEFT) with stack (RIGHT)
    // CMPD does: D - [S], so we want LEFT - RIGHT
    emit_simple_expr(right, out, assets);
    out.push_str("    LDD RESULT\n");
    out.push_str("    PSHS D\n");          // Push RIGHT to stack
    
    emit_simple_expr(left, out, assets);
    out.push_str("    LDD RESULT\n");      // D = LEFT
    out.push_str("    CMPD ,S++\n");       // Compare LEFT - RIGHT (sets flags correctly)
    
    let branch_true = match op {
        CmpOp::Eq => "LBEQ",
        CmpOp::Ne => "LBNE",
        CmpOp::Lt => "LBLT",
        CmpOp::Le => "LBLE",
        CmpOp::Gt => "LBGT",
        CmpOp::Ge => "LBGE",
    };
    
    out.push_str(&format!("    {} .CMP_{}_TRUE\n", branch_true, id));
    out.push_str("    LDD #0\n");
    out.push_str(&format!("    LBRA .CMP_{}_END\n", id));
    out.push_str(&format!(".CMP_{}_TRUE:\n", id));
    out.push_str("    LDD #1\n");
    out.push_str(&format!(".CMP_{}_END:\n", id));
    out.push_str("    STD RESULT\n");
}

fn emit_index(array: &Expr, index: &Expr, out: &mut String, assets: &[AssetInfo]) {
    // CRITICAL FIX (2026-01-19): Use correct label based on array type
    // Mutable arrays (GlobalLet): VAR_{NAME}_DATA (in RAM)
    // Const arrays: ARRAY_{NAME}_DATA (in ROM)
    // Use context::is_mutable_array() to check which type
    if let Expr::Ident(id) = array {
        let name_upper = id.name.to_uppercase();
        let label = if context::is_mutable_array(&id.name) {
            format!("VAR_{}_DATA", name_upper)  // RAM
        } else {
            format!("ARRAY_{}_DATA", name_upper)  // ROM
        };
        out.push_str(&format!("    LDX #{}  ; Array data\n", label));
        out.push_str("    PSHS X\n");  // CRITICAL: Save X before evaluating index
    } else {
        // Complex array expression - evaluate it
        emit_simple_expr(array, out, assets);
        out.push_str("    LDX RESULT  ; Array base address\n");
        out.push_str("    PSHS X\n");
    }
    
    // Evaluate index
    emit_simple_expr(index, out, assets);
    out.push_str("    LDD RESULT  ; Index\n");
    out.push_str("    ASLB        ; Multiply by 2 (16-bit elements)\n");
    out.push_str("    ROLA\n");
    
    // Calculate address
    out.push_str("    PULS X      ; Array base\n");
    out.push_str("    LEAX D,X    ; X = base + (index * 2)\n");
    out.push_str("    LDD ,X      ; Load value\n");
    out.push_str("    STD RESULT\n");
}
