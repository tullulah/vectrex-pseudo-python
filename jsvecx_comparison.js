/*
JSVecx Comparison Test Script
Genera archivos de comparaciÃ³n equivalentes a los tests de Rust
*/

const fs = require('fs');
const path = require('path');

// Cargar JSVecx (archivos compilados)
const JSVecxPath = path.join(__dirname, 'jsvecx', 'src', 'deploy', 'js');

// Necesitamos cargar todos los archivos en orden
eval(fs.readFileSync(path.join(JSVecxPath, 'utils.js'), 'utf8'));
eval(fs.readFileSync(path.join(JSVecxPath, 'globals.js'), 'utf8'));
eval(fs.readFileSync(path.join(JSVecxPath, 'vector_t.js'), 'utf8'));
eval(fs.readFileSync(path.join(JSVecxPath, 'e6809.js'), 'utf8'));
eval(fs.readFileSync(path.join(JSVecxPath, 'e8910.js'), 'utf8'));
eval(fs.readFileSync(path.join(JSVecxPath, 'osint.js'), 'utf8'));
eval(fs.readFileSync(path.join(JSVecxPath, 'vecx.js'), 'utf8'));

function formatHex(value, digits) {
    return value.toString(16).toUpperCase().padStart(digits, '0');
}

function formatReg8(value) {
    return formatHex(value & 0xFF, 2);
}

function formatReg16(value) {
    return formatHex(value & 0xFFFF, 4);
}

function captureEmulatorState(vecx, step) {
    const cpu = vecx.e6809;
    
    // Obtener valores de registros (algunos son objetos fptr)
    const pc = cpu.reg_pc & 0xFFFF;
    const a = cpu.reg_a & 0xFF;
    const b = cpu.reg_b & 0xFF;
    const x = (cpu.reg_x.value !== undefined ? cpu.reg_x.value : cpu.reg_x) & 0xFFFF;
    const y = (cpu.reg_y.value !== undefined ? cpu.reg_y.value : cpu.reg_y) & 0xFFFF;
    const s = (cpu.reg_s.value !== undefined ? cpu.reg_s.value : cpu.reg_s) & 0xFFFF;
    const u = (cpu.reg_u.value !== undefined ? cpu.reg_u.value : cpu.reg_u) & 0xFFFF;
    const dp = cpu.reg_dp & 0xFF;
    const cc = cpu.reg_cc & 0xFF;
    
    // Leer opcode actual
    let opcode = 0;
    try {
        opcode = vecx.read8(pc) & 0xFF;
    } catch (e) {
        opcode = 0;
    }
    
    return {
        step,
        pc,
        opcode,
        a,
        b,
        x,
        y,
        s,
        u,
        dp,
        cc
    };
}

function runJSVecxComparison(steps, filename) {
    console.log(`=== COMPARACIÃ“N JSVecx (${steps} pasos) ===`);
    
    // Crear instancia de JSVecx
    const vecx = new VecX();
    
    console.log('JSVecx creado, verificando arrays...');
    console.log('vecx.rom:', vecx.rom ? `Array(${vecx.rom.length})` : 'null');
    console.log('vecx.e6809:', vecx.e6809 ? 'presente' : 'null');
    
    // Cargar BIOS
    const biosPath = path.join(__dirname, 'ide', 'frontend', 'dist', 'bios.bin');
    if (!fs.existsSync(biosPath)) {
        throw new Error(`BIOS no encontrada en: ${biosPath}`);
    }
    
    const biosData = fs.readFileSync(biosPath);
    console.log(`Cargando BIOS: ${biosPath} (${biosData.length} bytes)`);
    
    // JSVecx espera que la BIOS estÃ© en Globals.romdata como string
    let romString = '';
    for (let i = 0; i < biosData.length; i++) {
        romString += String.fromCharCode(biosData[i]);
    }
    
    // Asegurarnos de que Globals.romdata estÃ© disponible
    if (typeof Globals === 'undefined') {
        global.Globals = {};
    }
    Globals.romdata = romString;
    
    console.log('BIOS convertida a string para JSVecx');
    
    // Inicializar sÃ³lo el CPU (osint requiere DOM)
    try {
        console.log('Inicializando CPU...');
        vecx.e6809.init(vecx);
        console.log('Ejecutando reset...');
        vecx.vecx_reset();
        console.log('Emulador inicializado');
    } catch (e) {
        console.error('Error inicializando emulador:', e.message);
        throw e;
    }
    
    const states = [];
    const pcCounts = new Map();
    
    // Ejecutar pasos individuales
    for (let step = 0; step < steps; step++) {
        // Capturar estado antes del paso
        const state = captureEmulatorState(vecx, step);
        states.push(state);
        
        // Contar frecuencia de PC
        pcCounts.set(state.pc, (pcCounts.get(state.pc) || 0) + 1);
        
        // Ejecutar un solo paso de CPU
        try {
            vecx.e6809.e6809_sstep(vecx.via_ifr & 0x80, 0);
        } catch (e) {
            console.log(`Error en paso ${step}: ${e.message}`);
            break;
        }
    }
    
    // Generar archivo de salida
    const content = generateComparisonFile(steps, states, pcCounts);
    fs.writeFileSync(filename, content, 'utf8');
    
    console.log(`Estados capturados: ${states.length}`);
    console.log(`ðŸ“„ Resultados guardados en: ${filename}`);
    
    return states;
}

function generateComparisonFile(steps, states, pcCounts) {
    const lines = [];
    
    lines.push(`=== COMPARACIÃ“N JSVecx (${steps} pasos) ===`);
    lines.push('Generated by JSVecx emulator test');
    lines.push('BIOS Path: C:\\Users\\DanielFerrerGuerrero\\source\\repos\\pseudo-python\\ide\\frontend\\dist\\bios.bin');
    lines.push('');
    
    // Tabla de ejecuciÃ³n
    lines.push('â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”');
    lines.push('â”‚ Step â”‚  PC  â”‚ Opcode â”‚ A  â”‚ B  â”‚  X   â”‚  Y   â”‚  S   â”‚  U   â”‚ DP â”‚ CC â”‚');
    lines.push('â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤');
    
    const maxDisplay = Math.min(50, states.length);
    for (let i = 0; i < maxDisplay; i++) {
        const state = states[i];
        lines.push(`â”‚ ${state.step.toString().padStart(4)} â”‚ ${formatReg16(state.pc)} â”‚   0x${formatReg8(state.opcode)}   â”‚ ${formatReg8(state.a)} â”‚ ${formatReg8(state.b)} â”‚ ${formatReg16(state.x)} â”‚ ${formatReg16(state.y)} â”‚ ${formatReg16(state.s)} â”‚ ${formatReg16(state.u)} â”‚ ${formatReg8(state.dp)} â”‚ ${formatReg8(state.cc)} â”‚`);
    }
    
    if (states.length > maxDisplay) {
        lines.push('â”‚ ...  â”‚ ...  â”‚  ...   â”‚ .. â”‚ .. â”‚ .... â”‚ .... â”‚ .... â”‚ .... â”‚ .. â”‚ .. â”‚');
        
        // Mostrar Ãºltimos estados
        for (let i = Math.max(maxDisplay, states.length - 10); i < states.length; i++) {
            const state = states[i];
            lines.push(`â”‚ ${state.step.toString().padStart(4)} â”‚ ${formatReg16(state.pc)} â”‚   0x${formatReg8(state.opcode)}   â”‚ ${formatReg8(state.a)} â”‚ ${formatReg8(state.b)} â”‚ ${formatReg16(state.x)} â”‚ ${formatReg16(state.y)} â”‚ ${formatReg16(state.s)} â”‚ ${formatReg16(state.u)} â”‚ ${formatReg8(state.dp)} â”‚ ${formatReg8(state.cc)} â”‚`);
        }
    }
    
    lines.push('â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜');
    lines.push(`Estados capturados: ${states.length}`);
    lines.push('');
    
    // AnÃ¡lisis de patrones
    lines.push('=== ANÃLISIS ===');
    
    if (states.length > 50) {
        lines.push('Patrones frecuentes en los Ãºltimos 50 estados:');
        const recentStates = states.slice(-50);
        const recentPatterns = new Map();
        
        recentStates.forEach(state => {
            const key = `PC=${formatReg16(state.pc)} Opcode=0x${formatReg8(state.opcode)}`;
            recentPatterns.set(key, (recentPatterns.get(key) || 0) + 1);
        });
        
        const sortedPatterns = Array.from(recentPatterns.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
            
        sortedPatterns.forEach(([pattern, count]) => {
            lines.push(`  ${pattern} â†’ ${count} veces`);
        });
    }
    
    const uniquePCs = new Set(states.map(s => s.pc)).size;
    const biosInstructions = states.filter(s => s.pc >= 0xE000).length;
    
    lines.push(`Direcciones PC Ãºnicas visitadas: ${uniquePCs}`);
    lines.push(`Instrucciones ejecutadas en BIOS (>= 0xE000): ${biosInstructions}`);
    lines.push('');
    
    return lines.join('\n');
}

// FunciÃ³n para ejecutar todas las comparaciones
function runAllComparisons() {
    const testSizes = [100, 500, 1000, 2000, 5000];
    
    for (const size of testSizes) {
        try {
            const filename = path.join(__dirname, `jsvecx_comparison_${size}_steps.txt`);
            runJSVecxComparison(size, filename);
        } catch (error) {
            console.error(`Error ejecutando test de ${size} pasos:`, error.message);
        }
    }
}

// Ejecutar si se llama directamente
if (require.main === module) {
    console.log('Iniciando comparaciones JSVecx...');
    runAllComparisons();
    console.log('Comparaciones completadas.');
}