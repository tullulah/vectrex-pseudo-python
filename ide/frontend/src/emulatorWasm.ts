// Static import of wasm-bindgen glue. Requires running `npm run wasm:build` at least once.
// If the file is missing, Vite will error during dev build with a helpful message.
// @ts-ignore generated by wasm-bindgen (no TypeScript declarations emitted with --no-typescript)
import initWasm, { WasmEmu } from './wasm/vectrex_emulator.js';
// NOTA: Este archivo conserva EmulatorService para compatibilidad; nueva abstracciÃ³n en `emulatorCore.ts` / `rustWasmCore.ts`.

export interface VectorEvent { kind: 'move_to' | 'draw_vl'; pc: number; frame: number; }
export interface MetricsSnapshot {
  total: number;
  unimplemented: number;
  frames: number;
  cycle_frame?: number; // legacy naming alignment
  bios_frame?: number;
  draw_vl: number; // unified name (exported now by wasm). Fallback to draw_vl_count if absent.
  last_intensity: number;
  unique_unimplemented: number[];
  cycles: number;
  avg_cycles_per_frame?: number;
  top_opcodes: [number, number][]; // [opcode, count]
  first_unimpl?: number;
  // VIA debug additions
  via_t1: number;
  via_irq_count: number;
  via_irq_line: boolean;
  via_ifr: number;
  via_ier: number;
}
// NOTE: wasm registers_json now also includes cycle_frame & bios_frame; keep backward compat with optional fields.
export interface RegistersSnapshot { a:number;b:number;dp:number;x:number;y:number;u:number;s:number;pc:number;cycles:number;frame_count:number;cycle_frame?:number;bios_frame?:number;last_intensity:number;draw_vl_count?:number; }
export interface Segment { x0:number; y0:number; x1:number; y1:number; intensity:number; frame:number; }

export class EmulatorService {
  /** Devuelve true si el envelope PSG acaba de finalizar (evento one-shot, se limpia tras leer). */
  psgEnvJustFinished(): boolean {
    const anyEmu: any = this.emu;
    if (!anyEmu) return false;
    if (typeof anyEmu.psg_env_just_finished === 'function') {
      try { return !!anyEmu.psg_env_just_finished(); } catch { return false; }
    }
    return false;
  }
  private emu: WasmEmu | null = null;
  private memory: Uint8Array | null = null;
  private biosLoaded = false;
  private trace = false;
  private biosLoadingPromise: Promise<boolean> | null = null;
  private memoryDirty = true; // rebind view when pointer/memory may have changed

  enableTrace(on: boolean){ this.trace = on; (window as any).__emuTrace = on; }
  isTrace(){ return this.trace; }

  async init(wasmUrl?: string) {
    if (this.emu) return; // idempotent
    try {
      await initWasm(wasmUrl as any);
      this.emu = new (WasmEmu as any)();
      
      // ðŸ”§ CONFIGURACIÃ“N CRUCIAL: Deshabilitar auto-drain para acumular segmentos
      const emuAny: any = this.emu as any;
      if (typeof emuAny.set_integrator_auto_drain === 'function') {
        emuAny.set_integrator_auto_drain(false);
        if (this.trace) console.debug('[emu] integrator_auto_drain disabled para acumular segmentos');
      }
      
      // Expose for debugging / demo fallback
      (window as any).emu = this.emu;
    } catch (e:any) {
      console.error('[Emulator] WASM init failed. Did you run `npm run wasm:build`?', e);
      throw e;
    }
  }

  /** Ensure BIOS loaded exactly once. */
  async ensureBios(opts?: { bytes?: Uint8Array; urlCandidates?: string[] }): Promise<boolean> {
    if (this.biosLoaded) return true;
    if (!this.emu) await this.init();
    if (this.biosLoaded) return true;
    if (this.biosLoadingPromise) return this.biosLoadingPromise;
    const run = async (): Promise<boolean> => {
      if (opts?.bytes) {
        try { this.loadBios(opts.bytes); return true; } catch(e){ console.warn('[Emu] provided BIOS bytes failed', e); }
      }
      const list = opts?.urlCandidates || [];
      for (const u of list) {
        try {
          if (this.trace) console.debug('[Emu] BIOS fetch try', u);
          const resp = await fetch(u);
          if (resp.ok) {
            const buf = new Uint8Array(await resp.arrayBuffer());
            if (buf.length===4096 || buf.length===8192) {
              try { this.loadBios(buf); if (this.trace) console.debug('[Emu] BIOS loaded from', u, 'size', buf.length); return true; } catch(e){ console.warn('[Emu] loadBios failed for', u, e); }
            }
          }
        } catch { /* ignore */ }
      }
      return this.biosLoaded;
    };
    this.biosLoadingPromise = run().finally(()=>{ this.biosLoadingPromise = null; });
    return this.biosLoadingPromise;
  }

  loadBios(bytes: Uint8Array) {
    if (!this.emu) throw new Error('Emu not init');
    if (!this.emu.load_bios(bytes)) throw new Error('Invalid BIOS size');
    this.emu.reset();
    this.biosLoaded = true;
    this.memoryDirty = true;
  }

  isBiosLoaded() { return this.biosLoaded; }

  reset() { if (this.emu) { this.emu.reset(); } }

  resetStats() { if (this.emu && (this.emu as any).reset_stats) { (this.emu as any).reset_stats(); } }

  /** Load a raw program binary at the given base address (fixed cartridge origin now $0000). */
  loadProgram(bytes: Uint8Array, base = 0x0000) {
    if (!this.emu) throw new Error('Emu not init');
    // wasm API returns void; assume success unless it throws
    this.emu.load_bin(base, bytes);
    this.memoryDirty = true;
  }

  runFrame(maxInstr = 200_000) {
    if (!this.emu) return;
    if (!this.biosLoaded) { if (this.trace) console.warn('[emu] runFrame ignorado: BIOS no cargada'); return; }
    if (this.trace) console.debug('[emu] runFrame start maxInstr=', maxInstr);
    const anyEmu: any = this.emu as any;
    if (typeof anyEmu.run_until_wait_recal === 'function') {
      anyEmu.run_until_wait_recal(maxInstr);
    } else {
      // Fallback: si el mÃ©todo no estÃ¡, probablemente wasm glue desactualizado.
      if (!anyEmu.__warnedMissingRunUntil) {
        console.warn('[emu] run_until_wait_recal ausente. Ejecutando fallback con step(). Reâ€‘genera wasm: npm run wasm:build');
        anyEmu.__warnedMissingRunUntil = true;
      }
      // HeurÃ­stica: consumir instrucciones en bloques hasta exceder maxInstr.
      let remaining = maxInstr;
      const chunk = 2000;
      while (remaining > 0) {
        const exec = Math.min(chunk, remaining);
        if (typeof anyEmu.step === 'function') {
          anyEmu.step(exec);
        } else {
          break; // nada mÃ¡s que hacer
        }
        remaining -= exec;
      }
    }
    if (this.trace) {
      try { const m = this.metrics(); console.debug('[emu] runFrame done frame_count=', m?.frames, 'cycles=', m?.cycles); } catch {}
    }
  }

  setInput(x:number, y:number, buttons:number){
    const anyEmu:any = this.emu as any; if (!anyEmu) return;
    if (typeof anyEmu.set_input_state === 'function') {
      try { anyEmu.set_input_state(x,y,buttons); } catch(e){ if (this.trace) console.warn('set_input_state failed', e); }
    }
  }

  drainVectorEvents(): VectorEvent[] {
    if (!this.emu) return [];
    try { return JSON.parse(this.emu.vector_events_json()) as VectorEvent[]; } catch { return []; }
  }

  metrics(): MetricsSnapshot | null {
    if (!this.emu) return null;
    try { return JSON.parse(this.emu.metrics_json()) as MetricsSnapshot; } catch { return null; }
  }

  registers(): RegistersSnapshot | null {
    if (!this.emu) return null;
    try { return JSON.parse(this.emu.registers_json()) as RegistersSnapshot; } catch { return null; }
  }

  // ---- Trace helpers ----
  enableTraceCapture(on:boolean, limit=10_000){ const anyEmu:any=this.emu; if(anyEmu?.enable_trace){ anyEmu.enable_trace(on, limit); } }
  clearTrace(){ const anyEmu:any=this.emu; if(anyEmu?.trace_clear){ anyEmu.trace_clear(); } }
  traceLen(): number { const anyEmu:any=this.emu; return anyEmu?.trace_len ? anyEmu.trace_len() : 0; }
  traceLog(): any[]{ const anyEmu:any=this.emu; if(anyEmu?.trace_log_json){ try { return JSON.parse(anyEmu.trace_log_json()); } catch{} } return []; }

  // BIOS call stack helpers (new wasm API)
  biosCalls(): string[] { const anyEmu:any=this.emu; if(anyEmu?.bios_calls_json){ try { return JSON.parse(anyEmu.bios_calls_json()) as string[]; } catch{} } return []; }
  clearBiosCalls(){ const anyEmu:any=this.emu; if(anyEmu?.clear_bios_calls){ try { anyEmu.clear_bios_calls(); } catch{} } }


  loopWatch(): any[] {
    if (!this.emu) return [];
    try { return JSON.parse((this.emu as any).loop_watch_json()) as any[]; } catch { return []; }
  }

  getSegmentsShared(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (!emuAny.integrator_segments_ptr) return [];
    const ptr = emuAny.integrator_segments_ptr();
    const len = emuAny.integrator_segments_len();
    const stride = emuAny.integrator_segment_stride();
    if (this.trace) console.debug('[emu] getSegmentsShared ptr=',ptr,'len=',len,'stride=',stride);
    // wasm-bindgen usually exposes memory on the default export; attempt to discover
    const mem: WebAssembly.Memory | undefined = (emuAny.memory) || (emuAny.constructor?.memory) || ( (globalThis as any).wasmMemory );
    if (!mem) return [];
    const bytes = new Uint8Array(mem.buffer, ptr, len * stride);
    const segs: Segment[] = [];
    for (let i=0;i<len;i++) {
      const off = i*stride;
      const dv = new DataView(bytes.buffer, bytes.byteOffset + off, stride);
      const x0 = dv.getFloat32(0, true);
      const y0 = dv.getFloat32(4, true);
      const x1 = dv.getFloat32(8, true);
      const y1 = dv.getFloat32(12, true);
      const intensity = dv.getUint16(16, true);
      const frame = dv.getUint32(20, true);
      segs.push({x0,y0,x1,y1,intensity,frame});
    }
    return segs;
  }
  drainSegmentsJson(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (!emuAny.integrator_segments_json) return [];
    try {
      const raw = emuAny.integrator_segments_json();
      const segs = JSON.parse(raw) as Segment[];
      if (this.trace) console.debug('[emu] drainSegmentsJson count=', segs.length);
      return segs;
    } catch { return []; }
  }
  peekSegmentsJson(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (!emuAny.integrator_segments_peek_json) return [];
    try {
      const raw = emuAny.integrator_segments_peek_json();
      const segs = JSON.parse(raw) as Segment[];
      if (this.trace) console.debug('[emu] peekSegmentsJson count=', segs.length);
      return segs;
    } catch { return []; }
  }
  drainSegments() {
    if (!this.emu) return;
    const emuAny: any = this.emu as any;
    if (emuAny.integrator_drain_segments) emuAny.integrator_drain_segments();
  }

  /** Generate a static demo triangle using wasm helper if available; returns latest segments. */
  demoTriangle(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (typeof emuAny.demo_triangle === 'function') {
      try { emuAny.demo_triangle(); } catch(e){ console.warn('demo_triangle call failed', e); }
      // Prefer peek (non-drain) if available
      if (typeof emuAny.integrator_segments_peek_json === 'function') {
        try { return JSON.parse(emuAny.integrator_segments_peek_json()) as Segment[]; } catch { /* ignore */ }
      }
      if (typeof emuAny.integrator_segments_json === 'function') {
        try { return JSON.parse(emuAny.integrator_segments_json()) as Segment[]; } catch { /* ignore */ }
      }
    }
    return [];
  }

  /** Returns a full 64K snapshot (Uint8Array copy) of emulated memory. */
  snapshotMemory(): Uint8Array {
    const anyEmu: any = this.emu as any; if (!anyEmu) return new Uint8Array();
    // Rebind if first time or flagged dirty (BIOS/program loaded, reset, or memory grew)
    if (!this.memory || this.memoryDirty) {
      const buf = (anyEmu.memory?.buffer) || (anyEmu.constructor?.memory?.buffer) || (globalThis as any).wasmMemory?.buffer;
      const ptr = anyEmu.memory_ptr?.() || 0;
      this.memory = new Uint8Array(buf, ptr, 65536);
      this.memoryDirty = false;
    }
    const src = this.memory;
    const out = new Uint8Array(65536);
    out.set(src);
    // Heuristic fallback: if everything looks zero but wasm helper read_mem8 shows data, rebuild manually.
    if (this.biosLoaded) {
      let nonZero = false;
      for (let i=0;i<512;i++){ if (out[i]!==0){ nonZero=true; break; } }
      if (!nonZero) {
        try {
          // Probe a few addresses via direct API
            const probe0 = typeof anyEmu.read_mem8 === 'function' ? anyEmu.read_mem8(0) : 0;
            const probeBios = typeof anyEmu.read_mem8 === 'function' ? anyEmu.read_mem8(0xE000) : 0;
            if ((probe0|probeBios) !== 0) {
              if (this.trace) console.warn('[emu] snapshotMemory primary view all zero; falling back to per-byte read_mem8 copy');
              for (let a=0;a<65536;a++){ out[a] = anyEmu.read_mem8(a & 0xFFFF); }
            }
        } catch(err) { /* ignore */ }
      }
    }
    return out;
  }

  /** Force next snapshotMemory call to rebind underlying view. */
  invalidateMemoryView(){ this.memoryDirty = true; }
}

// La instancia global directa se deja de exportar en favor de factory. Este archivo ya no define `globalEmu`.
// Herramientas globales se moverÃ¡n en una fase posterior si se requieren sobre la abstracciÃ³n.
