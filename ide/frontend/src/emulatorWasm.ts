// Static import of wasm-bindgen glue. Requires running `npm run wasm:build` at least once.
// If the file is missing, Vite will error during dev build with a helpful message.
// @ts-ignore generated by wasm-bindgen (no TypeScript declarations emitted with --no-typescript)
import initWasm, { WasmEmu } from './wasm/vectrex_emulator.js';

export interface VectorEvent { kind: 'move_to' | 'draw_vl'; pc: number; frame: number; }
export interface MetricsSnapshot {
  total: number;
  unimplemented: number;
  frames: number;
  draw_vl: number;
  last_intensity: number;
  unique_unimplemented: number[];
  cycles: number;
  avg_cycles_per_frame?: number;
  top_opcodes: [number, number][]; // [opcode, count]
  first_unimpl?: number;
  // VIA debug additions
  via_t1: number;
  via_irq_count: number;
  via_irq_line: boolean;
  via_ifr: number;
  via_ier: number;
}
// NOTE: wasm registers_json now also includes cycle_frame & bios_frame; keep backward compat with optional fields.
export interface RegistersSnapshot { a:number;b:number;dp:number;x:number;y:number;u:number;s:number;pc:number;cycles:number;frame_count:number;cycle_frame?:number;bios_frame?:number;last_intensity:number;draw_vl_count?:number; }
export interface Segment { x0:number; y0:number; x1:number; y1:number; intensity:number; frame:number; }

export class EmulatorService {
  private emu: WasmEmu | null = null;
  private memory: Uint8Array | null = null;
  private biosLoaded = false;

  async init(wasmUrl?: string) {
    if (this.emu) return; // idempotent
    try {
      await initWasm(wasmUrl as any);
      this.emu = new (WasmEmu as any)();
      // Expose for debugging / demo fallback
      (window as any).emu = this.emu;
    } catch (e:any) {
      console.error('[Emulator] WASM init failed. Did you run `npm run wasm:build`?', e);
      throw e;
    }
  }

  loadBios(bytes: Uint8Array) {
    if (!this.emu) throw new Error('Emu not init');
    if (!this.emu.load_bios(bytes)) throw new Error('Invalid BIOS size');
    this.emu.reset();
    this.biosLoaded = true;
  }

  isBiosLoaded() { return this.biosLoaded; }

  reset() { if (this.emu) { this.emu.reset(); } }

  resetStats() { if (this.emu && (this.emu as any).reset_stats) { (this.emu as any).reset_stats(); } }

  /** Load a raw program binary at the given base address (defaults to 0xC000 typical cartridge). */
  loadProgram(bytes: Uint8Array, base = 0xC000) {
    if (!this.emu) throw new Error('Emu not init');
    // wasm API returns void; assume success unless it throws
    this.emu.load_bin(base, bytes);
  }

  runFrame(maxInstr = 200_000) {
    if (!this.emu) return;
    this.emu.run_until_wait_recal(maxInstr);
  }

  drainVectorEvents(): VectorEvent[] {
    if (!this.emu) return [];
    try { return JSON.parse(this.emu.vector_events_json()) as VectorEvent[]; } catch { return []; }
  }

  metrics(): MetricsSnapshot | null {
    if (!this.emu) return null;
    try { return JSON.parse(this.emu.metrics_json()) as MetricsSnapshot; } catch { return null; }
  }

  registers(): RegistersSnapshot | null {
    if (!this.emu) return null;
    try { return JSON.parse(this.emu.registers_json()) as RegistersSnapshot; } catch { return null; }
  }


  loopWatch(): any[] {
    if (!this.emu) return [];
    try { return JSON.parse((this.emu as any).loop_watch_json()) as any[]; } catch { return []; }
  }

  getSegmentsShared(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (!emuAny.integrator_segments_ptr) return [];
    const ptr = emuAny.integrator_segments_ptr();
    const len = emuAny.integrator_segments_len();
    const stride = emuAny.integrator_segment_stride();
    // wasm-bindgen usually exposes memory on the default export; attempt to discover
    const mem: WebAssembly.Memory | undefined = (emuAny.memory) || (emuAny.constructor?.memory) || ( (globalThis as any).wasmMemory );
    if (!mem) return [];
    const bytes = new Uint8Array(mem.buffer, ptr, len * stride);
    const segs: Segment[] = [];
    for (let i=0;i<len;i++) {
      const off = i*stride;
      const dv = new DataView(bytes.buffer, bytes.byteOffset + off, stride);
      const x0 = dv.getFloat32(0, true);
      const y0 = dv.getFloat32(4, true);
      const x1 = dv.getFloat32(8, true);
      const y1 = dv.getFloat32(12, true);
      const intensity = dv.getUint16(16, true);
      const frame = dv.getUint32(20, true);
      segs.push({x0,y0,x1,y1,intensity,frame});
    }
    return segs;
  }
  drainSegmentsJson(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (!emuAny.integrator_segments_json) return [];
    try { return JSON.parse(emuAny.integrator_segments_json()) as Segment[]; } catch { return []; }
  }
  peekSegmentsJson(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (!emuAny.integrator_segments_peek_json) return [];
    try { return JSON.parse(emuAny.integrator_segments_peek_json()) as Segment[]; } catch { return []; }
  }
  drainSegments() {
    if (!this.emu) return;
    const emuAny: any = this.emu as any;
    if (emuAny.integrator_drain_segments) emuAny.integrator_drain_segments();
  }

  /** Generate a static demo triangle using wasm helper if available; returns latest segments. */
  demoTriangle(): Segment[] {
    if (!this.emu) return [];
    const emuAny: any = this.emu as any;
    if (typeof emuAny.demo_triangle === 'function') {
      try { emuAny.demo_triangle(); } catch(e){ console.warn('demo_triangle call failed', e); }
      // Prefer peek (non-drain) if available
      if (typeof emuAny.integrator_segments_peek_json === 'function') {
        try { return JSON.parse(emuAny.integrator_segments_peek_json()) as Segment[]; } catch { /* ignore */ }
      }
      if (typeof emuAny.integrator_segments_json === 'function') {
        try { return JSON.parse(emuAny.integrator_segments_json()) as Segment[]; } catch { /* ignore */ }
      }
    }
    return [];
  }
}

export const globalEmu = new EmulatorService();
